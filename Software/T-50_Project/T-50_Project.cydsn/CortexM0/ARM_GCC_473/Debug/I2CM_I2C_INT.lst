ARM GAS  C:\Users\SNFU\AppData\Local\Temp\ccgMdgju.s 			page 1


   1              		.cpu cortex-m0
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 4
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.code	16
  13              		.file	"I2CM_I2C_INT.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.text.I2CM_I2C_ISR,"ax",%progbits
  18              		.align	1
  19              		.global	I2CM_I2C_ISR
  20              		.code	16
  21              		.thumb_func
  22              		.type	I2CM_I2C_ISR, %function
  23              	I2CM_I2C_ISR:
  24              	.LFB0:
  25              		.file 1 ".\\Generated_Source\\PSoC4\\I2CM_I2C_INT.c"
   1:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** /*******************************************************************************
   2:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** * File Name: I2CM_I2C_INT.c
   3:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** * Version 1.20
   4:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** *
   5:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** * Description:
   6:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** *  This file provides the source code to the Interrupt Service Routine for
   7:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** *  the SCB Component in I2C mode.
   8:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** *
   9:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** * Note:
  10:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** *
  11:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** ********************************************************************************
  12:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** * Copyright 2013-2014, Cypress Semiconductor Corporation.  All rights reserved.
  13:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** * You may use this file only in accordance with the license, terms, conditions,
  14:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** * disclaimers, and limitations in the end user license agreement accompanying
  15:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** * the software package with which this file was provided.
  16:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** *******************************************************************************/
  17:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** 
  18:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** #include "I2CM_PVT.h"
  19:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** #include "I2CM_I2C_PVT.h"
  20:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** 
  21:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** 
  22:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** /*******************************************************************************
  23:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** * Function Name: I2CM_I2C_ISR
  24:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** ********************************************************************************
  25:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** *
  26:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** * Summary:
  27:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** *  Handles the Interrupt Service Routine for the SCB I2C mode.
  28:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** *
  29:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** * Parameters:
  30:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** *  None
  31:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** *
  32:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** * Return:
ARM GAS  C:\Users\SNFU\AppData\Local\Temp\ccgMdgju.s 			page 2


  33:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** *  None
  34:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** *
  35:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** *******************************************************************************/
  36:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** CY_ISR(I2CM_I2C_ISR)
  37:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** {
  26              		.loc 1 37 0
  27              		.cfi_startproc
  28              	.LVL0:
  29 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
  30              	.LCFI0:
  31              		.cfi_def_cfa_offset 24
  32              		.cfi_offset 3, -24
  33              		.cfi_offset 4, -20
  34              		.cfi_offset 5, -16
  35              		.cfi_offset 6, -12
  36              		.cfi_offset 7, -8
  37              		.cfi_offset 14, -4
  38:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****     uint32 diffCount;
  39:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****     uint32 endTransfer;
  40:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** 
  41:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****     #if(I2CM_CHECK_I2C_ACCEPT_ADDRESS_CONST)
  42:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****         uint32 address;
  43:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****     #endif /* (I2CM_CHECK_I2C_ACCEPT_ADDRESS_CONST) */
  44:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** 
  45:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****     endTransfer = 0u; /* Continue active transfer */
  46:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** 
  47:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****     /* Call customer routine if registered */
  48:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****     if(NULL != I2CM_customIntrHandler)
  38              		.loc 1 48 0
  39 0002 AD4B     		ldr	r3, .L75
  40 0004 1868     		ldr	r0, [r3]
  41 0006 0028     		cmp	r0, #0
  42 0008 00D0     		beq	.L2
  49:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****     {
  50:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****         I2CM_customIntrHandler();
  43              		.loc 1 50 0
  44 000a 8047     		blx	r0
  45              	.LVL1:
  46              	.L2:
  51:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****     }
  52:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** 
  53:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****     if(I2CM_CHECK_INTR_I2C_EC_MASKED(I2CM_INTR_I2C_EC_WAKE_UP))
  47              		.loc 1 53 0
  48 000c AB49     		ldr	r1, .L75+4
  49 000e 0A68     		ldr	r2, [r1]
  50 0010 D007     		lsl	r0, r2, #31
  51 0012 02D5     		bpl	.L3
  54:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****     {
  55:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****         /* Mask-off after wakeup */
  56:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****         I2CM_SetI2CExtClkInterruptMode(I2CM_NO_INTR_SOURCES);
  52              		.loc 1 56 0
  53 0014 AA4D     		ldr	r5, .L75+8
  54 0016 0024     		mov	r4, #0
  55 0018 2C60     		str	r4, [r5]
  56              	.L3:
  57:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****     }
  58:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** 
ARM GAS  C:\Users\SNFU\AppData\Local\Temp\ccgMdgju.s 			page 3


  59:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****     /* Master and Slave error tracking:
  60:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****     * Add the master state check to track only the master errors when the master is active or
  61:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****     * track slave errors when the slave is active or idle.
  62:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****     * A special MMS case: on the address phase with misplaced Start: the master sets the LOST_ARB a
  63:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****     * slave BUS_ERR. The valid event is LOST_ARB comes from the master.
  64:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****     */
  65:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****     if(I2CM_CHECK_I2C_FSM_MASTER)
  57              		.loc 1 65 0
  58 001a AA4B     		ldr	r3, .L75+12
  59 001c 1E78     		ldrb	r6, [r3]
  60 001e B106     		lsl	r1, r6, #26
  61 0020 01D4     		bmi	.L4
  62              	.LVL2:
  63              	.L9:
  45:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****     endTransfer = 0u; /* Continue active transfer */
  64              		.loc 1 45 0
  65 0022 0021     		mov	r1, #0
  66 0024 24E0     		b	.L5
  67              	.LVL3:
  68              	.L4:
  66:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****     {
  67:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****         #if(I2CM_I2C_MASTER)
  68:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****         {
  69:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****             /* INTR_MASTER_I2C_BUS_ERROR:
  70:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****             * A misplaced Start or Stop condition occurred on the bus: complete the transaction.
  71:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****             * The interrupt is cleared in the I2C_FSM_EXIT_IDLE.
  72:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****             */
  73:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****             if(I2CM_CHECK_INTR_MASTER_MASKED(I2CM_INTR_MASTER_I2C_BUS_ERROR))
  69              		.loc 1 73 0
  70 0026 A84F     		ldr	r7, .L75+16
  71 0028 3868     		ldr	r0, [r7]
  72 002a 391C     		mov	r1, r7
  45:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****     endTransfer = 0u; /* Continue active transfer */
  73              		.loc 1 45 0
  74 002c 0027     		mov	r7, #0
  75              		.loc 1 73 0
  76 002e C405     		lsl	r4, r0, #23
  77 0030 06D5     		bpl	.L6
  74:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****             {
  75:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 I2CM_mstrStatus |= (uint16) (I2CM_I2C_MSTAT_ERR_XFER |
  78              		.loc 1 75 0
  79 0032 A64A     		ldr	r2, .L75+20
  80 0034 C025     		mov	r5, #192
  81 0036 1488     		ldrh	r4, [r2]
  82 0038 AE00     		lsl	r6, r5, #2
  83 003a 2643     		orr	r6, r4
  84              	.LVL4:
  85 003c 1680     		strh	r6, [r2]
  86              	.LVL5:
  76:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                                                          I2CM_I2C_MSTAT_ERR_BUS_ERROR);
  77:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** 
  78:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 endTransfer = I2CM_I2C_CMPLT_ANY_TRANSFER;
  87              		.loc 1 78 0
  88 003e 0127     		mov	r7, #1
  89              	.LVL6:
  90              	.L6:
  79:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****             }
ARM GAS  C:\Users\SNFU\AppData\Local\Temp\ccgMdgju.s 			page 4


  80:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** 
  81:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****             /* INTR_MASTER_I2C_ARB_LOST:
  82:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****             * The MultiMaster lost arbitrage during the transaction.
  83:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****             * A Misplaced Start or Stop condition is treated as lost arbitration when the master dr
  84:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****             * The interrupt source is cleared in the I2C_FSM_EXIT_IDLE.
  85:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****             */
  86:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****             if(I2CM_CHECK_INTR_MASTER_MASKED(I2CM_INTR_MASTER_I2C_ARB_LOST))
  91              		.loc 1 86 0
  92 0040 0868     		ldr	r0, [r1]
  93 0042 C007     		lsl	r0, r0, #31
  94 0044 06D5     		bpl	.L7
  87:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****             {
  88:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 I2CM_mstrStatus |= (uint16) (I2CM_I2C_MSTAT_ERR_XFER |
  95              		.loc 1 88 0
  96 0046 A14A     		ldr	r2, .L75+20
  97 0048 9021     		mov	r1, #144
  98 004a 1488     		ldrh	r4, [r2]
  99              	.LVL7:
 100 004c 8D00     		lsl	r5, r1, #2
 101 004e 2543     		orr	r5, r4
 102              	.LVL8:
 103 0050 1580     		strh	r5, [r2]
 104              	.LVL9:
 105 0052 01E0     		b	.L8
 106              	.LVL10:
 107              	.L7:
  89:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                                                          I2CM_I2C_MSTAT_ERR_ARB_LOST);
  90:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** 
  91:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 endTransfer = I2CM_I2C_CMPLT_ANY_TRANSFER;
  92:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****             }
  93:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** 
  94:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****             #if(I2CM_I2C_MULTI_MASTER_SLAVE)
  95:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****             {
  96:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 /* I2C_MASTER_CMD_M_START_ON_IDLE:
  97:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 * The MultiMaster-Slave does not generate a start, because the Slave was addressed.
  98:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 * Pass control to the slave.
  99:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 */
 100:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 if(I2CM_CHECK_I2C_MASTER_CMD(I2CM_I2C_MASTER_CMD_M_START_ON_IDLE))
 101:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 {
 102:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     I2CM_mstrStatus |= (uint16) (I2CM_I2C_MSTAT_ERR_XFER |
 103:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                                                              I2CM_I2C_MSTAT_ERR_ABORT_XFER);
 104:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** 
 105:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     endTransfer = I2CM_I2C_CMPLT_ANY_TRANSFER;
 106:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 }
 107:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****             }
 108:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****             #endif
 109:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** 
 110:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****             /* The error handling common part:
 111:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****             * Set a completion flag of the master transaction and pass control to:
 112:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****             *  - I2C_FSM_EXIT_IDLE - to complete a transaction in case of: ARB_LOST or BUS_ERR.
 113:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****             *  - I2C_FSM_IDLE      - to take a chance for the slave to process the incoming transac
 114:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****             */
 115:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****             if(0u != endTransfer)
 108              		.loc 1 115 0
 109 0054 002F     		cmp	r7, #0
 110 0056 E4D0     		beq	.L9
 111              	.LVL11:
ARM GAS  C:\Users\SNFU\AppData\Local\Temp\ccgMdgju.s 			page 5


 112              	.L8:
 116:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****             {
 117:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 /* Set completion flags for master */
 118:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 I2CM_mstrStatus |= (uint16) I2CM_GET_I2C_MSTAT_CMPLT;
 113              		.loc 1 118 0
 114 0058 9C4E     		ldr	r6, .L75+20
 115 005a 0121     		mov	r1, #1
 116 005c 3788     		ldrh	r7, [r6]
 117              	.LVL12:
 118 005e 1878     		ldrb	r0, [r3]
 119:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** 
 120:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 #if(I2CM_I2C_MULTI_MASTER_SLAVE)
 121:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 {
 122:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     if(I2CM_CHECK_I2C_FSM_ADDR)
 123:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     {
 124:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         /* The Start generation was set after another master start accessing the Sl
 125:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         * Clean-up the master and turn to the slave. Set the state to IDLE.
 126:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         */
 127:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         if(I2CM_CHECK_I2C_MASTER_CMD(I2CM_I2C_MASTER_CMD_M_START_ON_IDLE))
 128:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         {
 129:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                             I2CM_I2C_MASTER_CLEAR_START;
 130:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** 
 131:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                             endTransfer = I2CM_I2C_CMPLT_ANY_TRANSFER; /* Pass control to Slave */
 132:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         }
 133:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         /* The valid arbitration lost on the address phase happens only when: maste
 134:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         * slave BUS_ERR is cleared. Only in that case set the state to IDLE without
 135:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         */
 136:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         else if((!I2CM_CHECK_INTR_SLAVE_MASKED(I2CM_INTR_SLAVE_I2C_BUS_ERROR))
 137:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                                && I2CM_CHECK_INTR_MASTER_MASKED(I2CM_INTR_MASTER_I2C_ARB_LOST))
 138:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         {
 139:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                             endTransfer = I2CM_I2C_CMPLT_ANY_TRANSFER; /* Pass control to Slave */
 140:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         }
 141:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         else
 142:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         {
 143:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                             endTransfer = 0u; /* Causes I2C_FSM_EXIT_IDLE to be set below */
 144:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         }
 145:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** 
 146:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         if(0u != endTransfer) /* Clean-up master to proceed with slave */
 147:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         {
 148:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                             I2CM_CLEAR_TX_FIFO; /* Shifter keeps address, clear it */
 149:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** 
 150:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                             I2CM_DISABLE_MASTER_AUTO_DATA_ACK; /* In case of reading disable autoAC
 151:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** 
 152:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                             /* Clean-up master interrupt sources */
 153:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                             I2CM_ClearMasterInterruptSource(I2CM_INTR_MASTER_ALL);
 154:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** 
 155:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                             /* Disable data processing interrupts: they should be cleared before */
 156:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                             I2CM_SetRxInterruptMode(I2CM_NO_INTR_SOURCES);
 157:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                             I2CM_SetTxInterruptMode(I2CM_NO_INTR_SOURCES);
 158:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** 
 159:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                             I2CM_state = I2CM_I2C_FSM_IDLE;
 160:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         }
 161:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         else
 162:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         {
 163:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                             /* Set I2C_FSM_EXIT_IDLE for BUS_ERR and ARB_LOST (that is really bus e
 164:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                             I2CM_state = I2CM_I2C_FSM_EXIT_IDLE;
 165:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         }
ARM GAS  C:\Users\SNFU\AppData\Local\Temp\ccgMdgju.s 			page 6


 166:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     }
 167:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     else
 168:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     {
 169:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         /* Set I2C_FSM_EXIT_IDLE if any other state than address */
 170:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         I2CM_state = I2CM_I2C_FSM_EXIT_IDLE;
 171:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     }
 172:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 }
 173:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 #else
 174:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 {
 175:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     /* In case of LOST*/
 176:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     I2CM_state = I2CM_I2C_FSM_EXIT_IDLE;
 119              		.loc 1 176 0
 120 0060 0024     		mov	r4, #0
 118:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 I2CM_mstrStatus |= (uint16) I2CM_GET_I2C_MSTAT_CMPLT;
 121              		.loc 1 118 0
 122 0062 0840     		and	r0, r1
 123 0064 4542     		neg	r5, r0
 124 0066 6841     		adc	r0, r0, r5
 125 0068 4218     		add	r2, r0, r1
 126 006a 3A43     		orr	r2, r7
 127              	.LVL13:
 128 006c 3280     		strh	r2, [r6]
 129              		.loc 1 176 0
 130 006e 1C70     		strb	r4, [r3]
 131              	.LVL14:
 132              	.L5:
 177:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 }
 178:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 #endif
 179:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****             }
 180:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****         }
 181:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****         #endif
 182:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****     }
 183:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****     else /* (I2CM_CHECK_I2C_FSM_SLAVE) */
 184:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****     {
 185:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****         #if(I2CM_I2C_SLAVE)
 186:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****         {
 187:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****             /* INTR_SLAVE_I2C_BUS_ERROR or I2CM_INTR_SLAVE_I2C_ARB_LOST:
 188:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****             * A Misplaced Start or Stop condition occurred on the bus: set a flag
 189:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****             * to notify an error condition.
 190:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****             */
 191:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****             if(I2CM_CHECK_INTR_SLAVE_MASKED(I2CM_INTR_SLAVE_I2C_BUS_ERROR |
 192:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                                                         I2CM_INTR_SLAVE_I2C_ARB_LOST))
 193:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****             {
 194:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 if(I2CM_CHECK_I2C_FSM_RD)
 195:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 {
 196:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     /* TX direction: master reads from slave */
 197:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     I2CM_slStatus &= (uint8) ~I2CM_I2C_SSTAT_RD_BUSY;
 198:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     I2CM_slStatus |= (uint8) (I2CM_I2C_SSTAT_RD_ERR |
 199:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                                                           I2CM_I2C_SSTAT_RD_CMPLT);
 200:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 }
 201:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 else
 202:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 {
 203:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     /* RX direction: master writes into slave */
 204:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     I2CM_slStatus &= (uint8) ~I2CM_I2C_SSTAT_WR_BUSY;
 205:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     I2CM_slStatus |= (uint8) (I2CM_I2C_SSTAT_WR_ERR |
 206:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                                                           I2CM_I2C_SSTAT_WR_CMPLT);
 207:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 }
ARM GAS  C:\Users\SNFU\AppData\Local\Temp\ccgMdgju.s 			page 7


 208:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** 
 209:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 I2CM_state = I2CM_I2C_FSM_EXIT_IDLE;
 210:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****             }
 211:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****         }
 212:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****         #endif
 213:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****     }
 214:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** 
 215:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****     /* States description:
 216:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****     * Any Master operation starts from: the ADDR_RD/WR state as the master generates traffic on the
 217:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****     * Any Slave operation starts from: the IDLE state as the slave always waits for actions from th
 218:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****     */
 219:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** 
 220:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****     /* FSM Master */
 221:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****     if(I2CM_CHECK_I2C_FSM_MASTER)
 133              		.loc 1 221 0
 134 0070 1D78     		ldrb	r5, [r3]
 135 0072 1022     		mov	r2, #16
 136 0074 AC06     		lsl	r4, r5, #26
 137 0076 00D4     		bmi	.LCB140
 138 0078 F5E0     		b	.L11	@long jump
 139              	.LCB140:
 222:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****     {
 223:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****         #if(I2CM_I2C_MASTER)
 224:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****         {
 225:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****             /* INTR_MASTER_I2C_STOP:
 226:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****             * A Stop condition was generated by the master: the end of the transaction.
 227:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****             * Set completion flags to notify the API.
 228:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****             */
 229:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****             if(I2CM_CHECK_INTR_MASTER_MASKED(I2CM_INTR_MASTER_I2C_STOP))
 140              		.loc 1 229 0
 141 007a 934E     		ldr	r6, .L75+16
 142              	.LVL15:
 143 007c 3068     		ldr	r0, [r6]
 144 007e 1042     		tst	r0, r2
 145 0080 0CD0     		beq	.L12
 230:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****             {
 231:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 I2CM_ClearMasterInterruptSource(I2CM_INTR_MASTER_I2C_STOP);
 146              		.loc 1 231 0
 147 0082 934C     		ldr	r4, .L75+24
 232:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** 
 233:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 I2CM_mstrStatus |= (uint16) I2CM_GET_I2C_MSTAT_CMPLT;
 148              		.loc 1 233 0
 149 0084 9149     		ldr	r1, .L75+20
 150              	.LVL16:
 231:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 I2CM_ClearMasterInterruptSource(I2CM_INTR_MASTER_I2C_STOP);
 151              		.loc 1 231 0
 152 0086 2260     		str	r2, [r4]
 153              		.loc 1 233 0
 154 0088 0F88     		ldrh	r7, [r1]
 155 008a 1D78     		ldrb	r5, [r3]
 156 008c 0120     		mov	r0, #1
 157 008e 2840     		and	r0, r5
 158 0090 4542     		neg	r5, r0
 159 0092 6841     		adc	r0, r0, r5
 160 0094 0130     		add	r0, r0, #1
 161 0096 3843     		orr	r0, r7
 162              	.LVL17:
ARM GAS  C:\Users\SNFU\AppData\Local\Temp\ccgMdgju.s 			page 8


 163 0098 0880     		strh	r0, [r1]
 164 009a D9E0     		b	.L73
 165              	.LVL18:
 166              	.L12:
 234:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 I2CM_state       = I2CM_I2C_FSM_IDLE;
 235:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****             }
 236:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****             else
 237:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****             {
 238:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 if(I2CM_CHECK_I2C_FSM_ADDR) /* Address stage */
 167              		.loc 1 238 0
 168 009c 1C78     		ldrb	r4, [r3]
 169 009e 2407     		lsl	r4, r4, #28
 170 00a0 1BD5     		bpl	.L15
 239:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 {
 240:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     /* INTR_MASTER_I2C_NACK:
 241:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     * The master has sent an address but it was NACKed by the slave. Complete trans
 242:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     */
 243:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     if(I2CM_CHECK_INTR_MASTER_MASKED(I2CM_INTR_MASTER_I2C_NACK))
 171              		.loc 1 243 0
 172 00a2 3568     		ldr	r5, [r6]
 173 00a4 0227     		mov	r7, #2
 174 00a6 3D42     		tst	r5, r7
 175 00a8 09D0     		beq	.L16
 244:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     {
 245:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         I2CM_ClearMasterInterruptSource(I2CM_INTR_MASTER_I2C_NACK);
 176              		.loc 1 245 0
 177 00aa 8949     		ldr	r1, .L75+24
 178              	.LVL19:
 246:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** 
 247:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         I2CM_mstrStatus |= (uint16) (I2CM_I2C_MSTAT_ERR_XFER |
 179              		.loc 1 247 0
 180 00ac 874C     		ldr	r4, .L75+20
 245:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         I2CM_ClearMasterInterruptSource(I2CM_INTR_MASTER_I2C_NACK);
 181              		.loc 1 245 0
 182 00ae 0F60     		str	r7, [r1]
 183              		.loc 1 247 0
 184 00b0 2588     		ldrh	r5, [r4]
 185 00b2 8827     		mov	r7, #136
 186 00b4 B800     		lsl	r0, r7, #2
 187 00b6 2843     		orr	r0, r5
 188              	.LVL20:
 189 00b8 2080     		strh	r0, [r4]
 190              	.LVL21:
 248:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                                                                  I2CM_I2C_MSTAT_ERR_ADDR_NAK);
 249:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** 
 250:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         endTransfer = I2CM_I2C_CMPLT_ANY_TRANSFER;
 191              		.loc 1 250 0
 192 00ba 0121     		mov	r1, #1
 193 00bc 0DE0     		b	.L15
 194              	.LVL22:
 195              	.L16:
 251:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     }
 252:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     /* INTR_TX_UNDERFLOW. The master has sent an address:
 253:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     *  - TX direction: the clock is stretched after the ACK phase, because the TX F
 254:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     *    EMPTY. The TX EMPTY cleans all the TX interrupt sources.
 255:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     *  - RX direction: the 1st byte is received, but there is no ACK permission,
 256:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     *    the clock is stretched after 1 byte is received.
ARM GAS  C:\Users\SNFU\AppData\Local\Temp\ccgMdgju.s 			page 9


 257:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     */
 258:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     else
 259:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     {
 260:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         if(I2CM_CHECK_I2C_FSM_RD) /* Reading */
 196              		.loc 1 260 0
 197 00be 1878     		ldrb	r0, [r3]
 198 00c0 C407     		lsl	r4, r0, #31
 199 00c2 02D5     		bpl	.L17
 261:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         {
 262:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                             I2CM_state = I2CM_I2C_FSM_MSTR_RD_DATA;
 200              		.loc 1 262 0
 201 00c4 2522     		mov	r2, #37
 202 00c6 1A70     		strb	r2, [r3]
 203 00c8 07E0     		b	.L15
 204              	.L17:
 263:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         }
 264:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         else /* Writing */
 265:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         {
 266:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                             I2CM_state = I2CM_I2C_FSM_MSTR_WR_DATA;
 205              		.loc 1 266 0
 206 00ca 2424     		mov	r4, #36
 267:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                             if(0u != I2CM_mstrWrBufSize)
 207              		.loc 1 267 0
 208 00cc 814D     		ldr	r5, .L75+28
 266:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                             I2CM_state = I2CM_I2C_FSM_MSTR_WR_DATA;
 209              		.loc 1 266 0
 210 00ce 1C70     		strb	r4, [r3]
 211              		.loc 1 267 0
 212 00d0 2F68     		ldr	r7, [r5]
 213 00d2 002F     		cmp	r7, #0
 214 00d4 01D0     		beq	.L15
 268:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                             {
 269:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                                 /* Enable INTR.TX_EMPTY if there is data to transmit */
 270:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                                 I2CM_SetTxInterruptMode(I2CM_INTR_TX_EMPTY);
 215              		.loc 1 270 0
 216 00d6 8048     		ldr	r0, .L75+32
 217 00d8 0260     		str	r2, [r0]
 218              	.LVL23:
 219              	.L15:
 271:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                             }
 272:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         }
 273:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     }
 274:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 }
 275:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** 
 276:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 if(I2CM_CHECK_I2C_FSM_DATA) /* Data phase */
 220              		.loc 1 276 0
 221 00da 1A78     		ldrb	r2, [r3]
 222 00dc 0424     		mov	r4, #4
 223 00de 2242     		tst	r2, r4
 224 00e0 00D1     		bne	.LCB244
 225 00e2 9AE0     		b	.L18	@long jump
 226              	.LCB244:
 277:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 {
 278:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     if(I2CM_CHECK_I2C_FSM_RD) /* Reading */
 227              		.loc 1 278 0
 228 00e4 1D78     		ldrb	r5, [r3]
 229 00e6 0120     		mov	r0, #1
ARM GAS  C:\Users\SNFU\AppData\Local\Temp\ccgMdgju.s 			page 10


 230              	.LVL24:
 231 00e8 0542     		tst	r5, r0
 232 00ea 43D0     		beq	.L19
 279:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     {
 280:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         /* INTR_RX_FULL:
 281:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         * RX direction: the master has received 8 bytes.
 282:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         * Get data from the RX FIFO and decide whether to ACK or  NACK the followin
 283:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         */
 284:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         if(I2CM_CHECK_INTR_RX_MASKED(I2CM_INTR_RX_FULL))
 233              		.loc 1 284 0
 234 00ec 7B4F     		ldr	r7, .L75+36
 235 00ee 0825     		mov	r5, #8
 236 00f0 3E68     		ldr	r6, [r7]
 237 00f2 2E42     		tst	r6, r5
 238 00f4 23D0     		beq	.L20
 285:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         {
 286:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                             /* Calculate difference */
 287:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                             diffCount =  I2CM_mstrRdBufSize -
 239              		.loc 1 287 0
 240 00f6 7A4C     		ldr	r4, .L75+40
 288:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                                         (I2CM_mstrRdBufIndex + I2CM_GET_RX_FIFO_ENTRIES);
 241              		.loc 1 288 0
 242 00f8 7A4F     		ldr	r7, .L75+44
 287:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                             diffCount =  I2CM_mstrRdBufSize -
 243              		.loc 1 287 0
 244 00fa 2668     		ldr	r6, [r4]
 245              		.loc 1 288 0
 246 00fc 7A4C     		ldr	r4, .L75+48
 247 00fe 2268     		ldr	r2, [r4]
 248 0100 3F68     		ldr	r7, [r7]
 249 0102 B61A     		sub	r6, r6, r2
 250 0104 0F22     		mov	r2, #15
 251 0106 3A40     		and	r2, r7
 287:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                             diffCount =  I2CM_mstrRdBufSize -
 252              		.loc 1 287 0
 253 0108 B21A     		sub	r2, r6, r2
 254              	.LVL25:
 289:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** 
 290:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                             /* Proceed transaction or end it when RX FIFO becomes FULL again */
 291:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                             if(diffCount > I2CM_FIFO_SIZE)
 255              		.loc 1 291 0
 256 010a AA42     		cmp	r2, r5
 257 010c 07D8     		bhi	.L39
 292:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                             {
 293:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                                 diffCount = I2CM_FIFO_SIZE;
 294:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                             }
 295:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                             else
 296:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                             {
 297:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                                 if(0u == diffCount)
 258              		.loc 1 297 0
 259 010e 002A     		cmp	r2, #0
 260 0110 06D1     		bne	.L59
 298:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                                 {
 299:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                                     I2CM_DISABLE_MASTER_AUTO_DATA_ACK;
 261              		.loc 1 299 0
 262 0112 764F     		ldr	r7, .L75+52
 263 0114 7649     		ldr	r1, .L75+56
ARM GAS  C:\Users\SNFU\AppData\Local\Temp\ccgMdgju.s 			page 11


 264              	.LVL26:
 265 0116 3E68     		ldr	r6, [r7]
 266 0118 3140     		and	r1, r6
 267 011a 3960     		str	r1, [r7]
 268              	.LVL27:
 300:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** 
 301:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                                     diffCount   = I2CM_FIFO_SIZE;
 302:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                                     endTransfer = I2CM_I2C_CMPLT_ANY_TRANSFER;
 269              		.loc 1 302 0
 270 011c 011C     		mov	r1, r0
 271              	.LVL28:
 272              	.L39:
 293:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                                 diffCount = I2CM_FIFO_SIZE;
 273              		.loc 1 293 0
 274 011e 2A1C     		mov	r2, r5
 275              	.LVL29:
 276              	.L59:
 303:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                                 }
 304:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                             }
 305:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** 
 306:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                             for(; (0u != diffCount); diffCount--)
 307:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                             {
 308:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                                 I2CM_mstrRdBufPtr[I2CM_mstrRdBufIndex] = (uint8)
 277              		.loc 1 308 0 discriminator 2
 278 0120 744D     		ldr	r5, .L75+60
 279 0122 2068     		ldr	r0, [r4]
 280 0124 2F68     		ldr	r7, [r5]
 306:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                             for(; (0u != diffCount); diffCount--)
 281              		.loc 1 306 0 discriminator 2
 282 0126 013A     		sub	r2, r2, #1
 283              	.LVL30:
 284              		.loc 1 308 0 discriminator 2
 285 0128 3E18     		add	r6, r7, r0
 286              	.LVL31:
 309:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                                                                                         I2CM_RX_FIF
 287              		.loc 1 309 0 discriminator 2
 288 012a 7348     		ldr	r0, .L75+64
 289 012c 0568     		ldr	r5, [r0]
 308:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                                 I2CM_mstrRdBufPtr[I2CM_mstrRdBufIndex] = (uint8)
 290              		.loc 1 308 0 discriminator 2
 291 012e EFB2     		uxtb	r7, r5
 292 0130 3770     		strb	r7, [r6]
 310:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                                 I2CM_mstrRdBufIndex++;
 293              		.loc 1 310 0 discriminator 2
 294 0132 2668     		ldr	r6, [r4]
 295 0134 0136     		add	r6, r6, #1
 296 0136 2660     		str	r6, [r4]
 297              	.LVL32:
 306:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                             for(; (0u != diffCount); diffCount--)
 298              		.loc 1 306 0 discriminator 2
 299 0138 002A     		cmp	r2, #0
 300 013a F1D1     		bne	.L59
 301 013c 17E0     		b	.L23
 302              	.LVL33:
 303              	.L20:
 311:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                             }
 312:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         }
ARM GAS  C:\Users\SNFU\AppData\Local\Temp\ccgMdgju.s 			page 12


 313:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         /* INTR_RX_NOT_EMPTY:
 314:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         * RX direction: the master has received one data byte, ACK or NACK it.
 315:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         * The last byte is stored and NACKed by the master. The NACK and Stop is
 316:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         * generated by one command generate Stop.
 317:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         */
 318:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         else if(I2CM_CHECK_INTR_RX_MASKED(I2CM_INTR_RX_NOT_EMPTY))
 304              		.loc 1 318 0
 305 013e 3A68     		ldr	r2, [r7]
 306 0140 2242     		tst	r2, r4
 307 0142 14D0     		beq	.L23
 319:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         {
 320:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                             /* Put data in component buffer */
 321:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                             I2CM_mstrRdBufPtr[I2CM_mstrRdBufIndex] = (uint8) I2CM_RX_FIFO_RD_REG;
 308              		.loc 1 321 0
 309 0144 684F     		ldr	r7, .L75+48
 310 0146 6B4E     		ldr	r6, .L75+60
 311 0148 3D68     		ldr	r5, [r7]
 312 014a 3268     		ldr	r2, [r6]
 313 014c 6A4E     		ldr	r6, .L75+64
 314 014e 5519     		add	r5, r2, r5
 315 0150 3268     		ldr	r2, [r6]
 316 0152 D6B2     		uxtb	r6, r2
 317 0154 2E70     		strb	r6, [r5]
 322:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                             I2CM_mstrRdBufIndex++;
 318              		.loc 1 322 0
 319 0156 3D68     		ldr	r5, [r7]
 323:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** 
 324:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                             if(I2CM_mstrRdBufIndex < I2CM_mstrRdBufSize)
 320              		.loc 1 324 0
 321 0158 614A     		ldr	r2, .L75+40
 322:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                             I2CM_mstrRdBufIndex++;
 322              		.loc 1 322 0
 323 015a 0135     		add	r5, r5, #1
 324 015c 3D60     		str	r5, [r7]
 325              	.LVL34:
 326              		.loc 1 324 0
 327 015e 3F68     		ldr	r7, [r7]
 328 0160 1668     		ldr	r6, [r2]
 329 0162 B742     		cmp	r7, r6
 330 0164 02D2     		bcs	.L40
 325:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                             {
 326:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                                 I2CM_I2C_MASTER_GENERATE_ACK;
 331              		.loc 1 326 0
 332 0166 6548     		ldr	r0, .L75+68
 333 0168 0460     		str	r4, [r0]
 334 016a 00E0     		b	.L23
 335              	.L40:
 327:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                             }
 328:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                             else
 329:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                             {
 330:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                                endTransfer = I2CM_I2C_CMPLT_ANY_TRANSFER;
 336              		.loc 1 330 0
 337 016c 011C     		mov	r1, r0
 338              	.LVL35:
 339              	.L23:
 331:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                             }
 332:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         }
ARM GAS  C:\Users\SNFU\AppData\Local\Temp\ccgMdgju.s 			page 13


 333:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         else
 334:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         {
 335:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                             /* Do nothing */
 336:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         }
 337:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** 
 338:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         I2CM_ClearRxInterruptSource(I2CM_INTR_RX_ALL);
 340              		.loc 1 338 0
 341 016e 6448     		ldr	r0, .L75+72
 342 0170 644C     		ldr	r4, .L75+76
 343 0172 48E0     		b	.L71
 344              	.LVL36:
 345              	.L19:
 339:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     }
 340:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     else /* Writing */
 341:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     {
 342:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         /* INTR_MASTER_I2C_NACK :
 343:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         * The master writes data to the slave and NACK was received: not all the by
 344:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         * written to the slave from the TX FIFO. Revert the index if there is data 
 345:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         * the TX FIFO and pass control to a complete transfer.
 346:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         */
 347:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         if(I2CM_CHECK_INTR_MASTER_MASKED(I2CM_INTR_MASTER_I2C_NACK))
 346              		.loc 1 347 0
 347 0174 3668     		ldr	r6, [r6]
 348 0176 0227     		mov	r7, #2
 349 0178 3E42     		tst	r6, r7
 350 017a 20D0     		beq	.L24
 348:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         {
 349:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                             I2CM_ClearMasterInterruptSource(I2CM_INTR_MASTER_I2C_NACK);
 351              		.loc 1 349 0
 352 017c 5449     		ldr	r1, .L75+24
 353              	.LVL37:
 350:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** 
 351:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                             /* Rollback write buffer index: NACKed byte remains in shifter */
 352:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                             I2CM_mstrWrBufIndexTmp -= (I2CM_GET_TX_FIFO_ENTRIES +
 354              		.loc 1 352 0
 355 017e 624A     		ldr	r2, .L75+80
 349:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                             I2CM_ClearMasterInterruptSource(I2CM_INTR_MASTER_I2C_NACK);
 356              		.loc 1 349 0
 357 0180 0F60     		str	r7, [r1]
 358              		.loc 1 352 0
 359 0182 624F     		ldr	r7, .L75+84
 360 0184 1568     		ldr	r5, [r2]
 361 0186 3E68     		ldr	r6, [r7]
 353:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                                                                    I2CM_GET_TX_FIFO_SR_VALID);
 362              		.loc 1 353 0
 363 0188 3C68     		ldr	r4, [r7]
 352:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                             I2CM_mstrWrBufIndexTmp -= (I2CM_GET_TX_FIFO_ENTRIES +
 364              		.loc 1 352 0
 365 018a 0F21     		mov	r1, #15
 366 018c 3140     		and	r1, r6
 367 018e E70B     		lsr	r7, r4, #15
 368 0190 6D1A     		sub	r5, r5, r1
 369 0192 3840     		and	r0, r7
 370 0194 281A     		sub	r0, r5, r0
 371              	.LVL38:
 372 0196 1060     		str	r0, [r2]
 373              	.LVL39:
ARM GAS  C:\Users\SNFU\AppData\Local\Temp\ccgMdgju.s 			page 14


 354:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** 
 355:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                             /* Update number of transferred bytes */
 356:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                             I2CM_mstrWrBufIndex = I2CM_mstrWrBufIndexTmp;
 374              		.loc 1 356 0
 375 0198 1668     		ldr	r6, [r2]
 376              	.LVL40:
 377 019a 5D4A     		ldr	r2, .L75+88
 357:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** 
 358:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                             I2CM_mstrStatus |= (uint16) (I2CM_I2C_MSTAT_ERR_XFER |
 378              		.loc 1 358 0
 379 019c 4B4C     		ldr	r4, .L75+20
 356:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                             I2CM_mstrWrBufIndex = I2CM_mstrWrBufIndexTmp;
 380              		.loc 1 356 0
 381 019e 1660     		str	r6, [r2]
 382              		.loc 1 358 0
 383 01a0 2588     		ldrh	r5, [r4]
 384 01a2 8421     		mov	r1, #132
 385 01a4 8F00     		lsl	r7, r1, #2
 386 01a6 2F43     		orr	r7, r5
 387              	.LVL41:
 388 01a8 2780     		strh	r7, [r4]
 359:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                                                                      I2CM_I2C_MSTAT_ERR_SHORT_XFER)
 360:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** 
 361:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                             I2CM_CLEAR_TX_FIFO;
 389              		.loc 1 361 0
 390 01aa 5A4F     		ldr	r7, .L75+92
 391              	.LVL42:
 392 01ac 8026     		mov	r6, #128
 393              	.LVL43:
 394 01ae 3868     		ldr	r0, [r7]
 395              	.LVL44:
 396 01b0 7202     		lsl	r2, r6, #9
 397 01b2 0243     		orr	r2, r0
 398 01b4 3A60     		str	r2, [r7]
 399 01b6 3C68     		ldr	r4, [r7]
 400 01b8 574E     		ldr	r6, .L75+96
 401 01ba 2640     		and	r6, r4
 402 01bc 2BE0     		b	.L72
 403              	.LVL45:
 404              	.L24:
 362:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** 
 363:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                             endTransfer = I2CM_I2C_CMPLT_ANY_TRANSFER;
 364:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         }
 365:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         /* INTR_TX_EMPTY :
 366:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         * TX direction: the TX FIFO is EMPTY, the data from the buffer needs to be 
 367:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         * When there is no data in the component buffer, the underflow interrupt is
 368:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         * enabled to catch when all the data has been transferred.
 369:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         */
 370:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         else if(I2CM_CHECK_INTR_TX_MASKED(I2CM_INTR_TX_EMPTY))
 405              		.loc 1 370 0
 406 01be 574A     		ldr	r2, .L75+100
 407 01c0 1468     		ldr	r4, [r2]
 408 01c2 E406     		lsl	r4, r4, #27
 409 01c4 21D5     		bpl	.L26
 371:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         {
 372:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                             while(I2CM_FIFO_SIZE != I2CM_GET_TX_FIFO_ENTRIES)
 373:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                             {
ARM GAS  C:\Users\SNFU\AppData\Local\Temp\ccgMdgju.s 			page 15


 374:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                                 /* The temporary mstrWrBufIndexTmp is used because slave could NACK
 375:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                                 * roll-back required in this case. The mstrWrBufIndex is updated at
 376:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                                 */
 377:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                                 if(I2CM_mstrWrBufIndexTmp < I2CM_mstrWrBufSize)
 378:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                                 {
 379:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                                 #if(!I2CM_CY_SCBIP_V0)
 380:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                                    /* Clear INTR_TX.UNDERFLOW before put last byte into the TX FIFO
 381:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                                     * proper trigger at the end of transaction when INTR_TX.UNDERFL
 382:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                                     * event. Ticket ID# 156735.
 383:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                                     */
 384:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                                     if(I2CM_mstrWrBufIndexTmp == (I2CM_mstrWrBufSize - 1u))
 385:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                                     {
 386:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                                         I2CM_ClearTxInterruptSource(I2CM_INTR_TX_UNDERFLOW);
 387:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                                         I2CM_SetTxInterruptMode(I2CM_INTR_TX_UNDERFLOW);
 388:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                                     }
 389:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                                  #endif /* (!I2CM_CY_SCBIP_V0) */
 390:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** 
 391:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                                     /* Put data into TX FIFO */
 392:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                                     I2CM_TX_FIFO_WR_REG = (uint32) I2CM_mstrWrBufPtr[I2CM_mstrWrBuf
 410              		.loc 1 392 0
 411 01c6 5648     		ldr	r0, .L75+104
 412 01c8 0568     		ldr	r5, [r0]
 413              	.LVL46:
 414              	.L27:
 372:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                             while(I2CM_FIFO_SIZE != I2CM_GET_TX_FIFO_ENTRIES)
 415              		.loc 1 372 0 discriminator 1
 416 01ca 504A     		ldr	r2, .L75+84
 417 01cc 0F26     		mov	r6, #15
 418              	.LVL47:
 419 01ce 1468     		ldr	r4, [r2]
 420 01d0 404F     		ldr	r7, .L75+28
 421 01d2 3440     		and	r4, r6
 422 01d4 4C4A     		ldr	r2, .L75+80
 423 01d6 082C     		cmp	r4, #8
 424 01d8 0CD0     		beq	.L28
 425              	.L29:
 377:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                                 if(I2CM_mstrWrBufIndexTmp < I2CM_mstrWrBufSize)
 426              		.loc 1 377 0
 427 01da 1068     		ldr	r0, [r2]
 428 01dc 3C68     		ldr	r4, [r7]
 429 01de A042     		cmp	r0, r4
 430 01e0 08D2     		bcs	.L28
 431              		.loc 1 392 0
 432 01e2 1668     		ldr	r6, [r2]
 433 01e4 4F48     		ldr	r0, .L75+108
 434 01e6 AF19     		add	r7, r5, r6
 435 01e8 3C78     		ldrb	r4, [r7]
 436 01ea 0460     		str	r4, [r0]
 393:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                                     I2CM_mstrWrBufIndexTmp++;
 437              		.loc 1 393 0
 438 01ec 1668     		ldr	r6, [r2]
 439 01ee 0136     		add	r6, r6, #1
 440 01f0 1660     		str	r6, [r2]
 441              	.LVL48:
 442 01f2 EAE7     		b	.L27
 443              	.LVL49:
 444              	.L28:
ARM GAS  C:\Users\SNFU\AppData\Local\Temp\ccgMdgju.s 			page 16


 394:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                                 }
 395:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                                 else
 396:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                                 {
 397:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                                     break; /* No more data to put */
 398:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                                 }
 399:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                             }
 400:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** 
 401:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         #if(I2CM_CY_SCBIP_V0)
 402:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                             if(I2CM_mstrWrBufIndexTmp == I2CM_mstrWrBufSize)
 445              		.loc 1 402 0
 446 01f4 1668     		ldr	r6, [r2]
 447 01f6 3F68     		ldr	r7, [r7]
 448 01f8 BE42     		cmp	r6, r7
 449 01fa 02D1     		bne	.L30
 403:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                             {
 404:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                                 I2CM_SetTxInterruptMode(I2CM_INTR_TX_UNDERFLOW);
 450              		.loc 1 404 0
 451 01fc 364A     		ldr	r2, .L75+32
 452 01fe 4025     		mov	r5, #64
 453 0200 1560     		str	r5, [r2]
 454              	.L30:
 405:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                             }
 406:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** 
 407:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                             I2CM_ClearTxInterruptSource(I2CM_INTR_TX_ALL);
 455              		.loc 1 407 0
 456 0202 4948     		ldr	r0, .L75+112
 457 0204 494C     		ldr	r4, .L75+116
 458              	.LVL50:
 459              	.L71:
 460 0206 2060     		str	r0, [r4]
 461 0208 07E0     		b	.L18
 462              	.LVL51:
 463              	.L26:
 408:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         #else
 409:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                             I2CM_ClearTxInterruptSource(I2CM_INTR_TX_EMPTY);
 410:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         #endif /* (I2CM_CY_SCBIP_V0) */
 411:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         }
 412:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         /* INTR_TX_UNDERFLOW:
 413:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         * TX direction: all data from the TX FIFO was transferred to the slave.
 414:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         * The transaction needs to be completed.
 415:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         */
 416:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         else if(I2CM_CHECK_INTR_TX_MASKED(I2CM_INTR_TX_UNDERFLOW))
 464              		.loc 1 416 0
 465 020a 1568     		ldr	r5, [r2]
 466 020c 6806     		lsl	r0, r5, #25
 467 020e 04D5     		bpl	.L18
 417:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         {
 418:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                             /* Update number of transferred bytes */
 419:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                             I2CM_mstrWrBufIndex = I2CM_mstrWrBufIndexTmp;
 468              		.loc 1 419 0
 469 0210 3D49     		ldr	r1, .L75+80
 470              	.LVL52:
 471 0212 3F4F     		ldr	r7, .L75+88
 472 0214 0E68     		ldr	r6, [r1]
 473              	.LVL53:
 474              	.L72:
 475 0216 3E60     		str	r6, [r7]
ARM GAS  C:\Users\SNFU\AppData\Local\Temp\ccgMdgju.s 			page 17


 476              	.LVL54:
 477 0218 01E0     		b	.L31
 478              	.LVL55:
 479              	.L18:
 420:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** 
 421:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                             endTransfer = I2CM_I2C_CMPLT_ANY_TRANSFER;
 422:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         }
 423:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         else
 424:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         {
 425:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                             /* Do nothing */
 426:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         }
 427:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     }
 428:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 }
 429:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** 
 430:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 if(0u != endTransfer) /* Complete transfer */
 480              		.loc 1 430 0
 481 021a 0029     		cmp	r1, #0
 482 021c 4AD0     		beq	.L1
 483              	.LVL56:
 484              	.L31:
 431:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 {
 432:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     /* Clean-up master after reading: only in case of NACK */
 433:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     I2CM_DISABLE_MASTER_AUTO_DATA_ACK;
 485              		.loc 1 433 0
 486 021e 334C     		ldr	r4, .L75+52
 487 0220 3349     		ldr	r1, .L75+56
 488 0222 2268     		ldr	r2, [r4]
 434:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** 
 435:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     /* Disable data processing interrupts: they should be cleared before */
 436:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     I2CM_SetRxInterruptMode(I2CM_NO_INTR_SOURCES);
 489              		.loc 1 436 0
 490 0224 424D     		ldr	r5, .L75+120
 491              	.LVL57:
 437:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     I2CM_SetTxInterruptMode(I2CM_NO_INTR_SOURCES);
 492              		.loc 1 437 0
 493 0226 2C4F     		ldr	r7, .L75+32
 436:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     I2CM_SetRxInterruptMode(I2CM_NO_INTR_SOURCES);
 494              		.loc 1 436 0
 495 0228 0020     		mov	r0, #0
 496              	.LVL58:
 433:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     I2CM_DISABLE_MASTER_AUTO_DATA_ACK;
 497              		.loc 1 433 0
 498 022a 1140     		and	r1, r2
 438:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** 
 439:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     if(I2CM_CHECK_I2C_MODE_NO_STOP(I2CM_mstrControl))
 499              		.loc 1 439 0
 500 022c 414E     		ldr	r6, .L75+124
 501              	.LVL59:
 433:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     I2CM_DISABLE_MASTER_AUTO_DATA_ACK;
 502              		.loc 1 433 0
 503 022e 2160     		str	r1, [r4]
 436:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     I2CM_SetRxInterruptMode(I2CM_NO_INTR_SOURCES);
 504              		.loc 1 436 0
 505 0230 2860     		str	r0, [r5]
 437:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     I2CM_SetTxInterruptMode(I2CM_NO_INTR_SOURCES);
 506              		.loc 1 437 0
 507 0232 3860     		str	r0, [r7]
ARM GAS  C:\Users\SNFU\AppData\Local\Temp\ccgMdgju.s 			page 18


 508              		.loc 1 439 0
 509 0234 3478     		ldrb	r4, [r6]
 510 0236 A107     		lsl	r1, r4, #30
 511 0238 0CD5     		bpl	.L32
 440:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     {
 441:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         /* On-going transaction is suspended: the ReStart is generated by the API r
 442:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         I2CM_mstrStatus |= (uint16) (I2CM_I2C_MSTAT_XFER_HALT |
 512              		.loc 1 442 0
 513 023a 244D     		ldr	r5, .L75+20
 514 023c 0122     		mov	r2, #1
 515 023e 2F88     		ldrh	r7, [r5]
 443:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                                                                  I2CM_GET_I2C_MSTAT_CMPLT);
 516              		.loc 1 443 0
 517 0240 1E78     		ldrb	r6, [r3]
 442:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         I2CM_mstrStatus |= (uint16) (I2CM_I2C_MSTAT_XFER_HALT |
 518              		.loc 1 442 0
 519 0242 3240     		and	r2, r6
 520 0244 5442     		neg	r4, r2
 521 0246 6241     		adc	r2, r2, r4
 522 0248 0932     		add	r2, r2, #9
 523 024a 3A43     		orr	r2, r7
 524              	.LVL60:
 525 024c 2A80     		strh	r2, [r5]
 444:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** 
 445:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         I2CM_state = I2CM_I2C_FSM_MSTR_HALT;
 526              		.loc 1 445 0
 527 024e 6022     		mov	r2, #96
 528              	.LVL61:
 529              	.L73:
 530 0250 1A70     		strb	r2, [r3]
 531 0252 2FE0     		b	.L1
 532              	.LVL62:
 533              	.L32:
 446:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     }
 447:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     else
 448:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     {
 449:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         /* Complete transaction: exclude the data processing state and generate Sto
 450:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         * The completion status will be set after Stop generation.
 451:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         * A special case is read: because NACK and Stop are generated by command be
 452:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         * The lost arbitration could occur during NACK generation in case when
 453:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         * other master is still reading from the slave.
 454:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         */
 455:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         I2CM_I2C_MASTER_GENERATE_STOP;
 534              		.loc 1 455 0
 535 0254 384B     		ldr	r3, .L75+128
 536 0256 1021     		mov	r1, #16
 537 0258 1A68     		ldr	r2, [r3]
 538 025a 9406     		lsl	r4, r2, #26
 539 025c 00D5     		bpl	.L34
 540 025e 1821     		mov	r1, #24
 541              	.L34:
 542              		.loc 1 455 0 is_stmt 0 discriminator 3
 543 0260 2648     		ldr	r0, .L75+68
 544 0262 0160     		str	r1, [r0]
 545 0264 26E0     		b	.L1
 546              	.LVL63:
 547              	.L11:
ARM GAS  C:\Users\SNFU\AppData\Local\Temp\ccgMdgju.s 			page 19


 456:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     }
 457:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 }
 458:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****             }
 459:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** 
 460:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****         } /* (I2CM_I2C_MASTER) */
 461:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****         #endif
 462:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** 
 463:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****     } /* (I2CM_CHECK_I2C_FSM_MASTER) */
 464:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** 
 465:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** 
 466:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****     /* FSM Slave */
 467:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****     else if(I2CM_CHECK_I2C_FSM_SLAVE)
 548              		.loc 1 467 0 is_stmt 1
 549 0266 1E78     		ldrb	r6, [r3]
 550              	.LVL64:
 551 0268 1640     		and	r6, r2
 552 026a 23D1     		bne	.L1
 468:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****     {
 469:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****         #if(I2CM_I2C_SLAVE)
 470:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****         {
 471:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****             /* INTR_SLAVE_NACK:
 472:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****             * The master completes reading the slave: the appropriate flags have to be set.
 473:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****             * The TX FIFO is cleared after an overflow condition is set.
 474:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****             */
 475:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****             if(I2CM_CHECK_INTR_SLAVE_MASKED(I2CM_INTR_SLAVE_I2C_NACK))
 476:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****             {
 477:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 I2CM_ClearSlaveInterruptSource(I2CM_INTR_SLAVE_I2C_NACK);
 478:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** 
 479:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 /* All entries that remain in TX FIFO max value is 9: 8 (FIFO) + 1 (SHIFTER) */
 480:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 diffCount = (I2CM_GET_TX_FIFO_ENTRIES + I2CM_GET_TX_FIFO_SR_VALID);
 481:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** 
 482:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 if(I2CM_slOverFlowCount > diffCount) /* Overflow */
 483:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 {
 484:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     I2CM_slStatus |= (uint8) I2CM_I2C_SSTAT_RD_OVFL;
 485:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 }
 486:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 else /* No Overflow */
 487:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 {
 488:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     /* Roll-back temporary index */
 489:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     I2CM_slRdBufIndexTmp -= (diffCount - I2CM_slOverFlowCount);
 490:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 }
 491:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** 
 492:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 /* Update slave of transferred bytes */
 493:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 I2CM_slRdBufIndex = I2CM_slRdBufIndexTmp;
 494:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** 
 495:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 /* Clean-up TX FIFO */
 496:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 I2CM_SetTxInterruptMode(I2CM_NO_INTR_SOURCES);
 497:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 I2CM_slOverFlowCount = 0u;
 498:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 I2CM_CLEAR_TX_FIFO;
 499:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** 
 500:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 /* Complete master reading */
 501:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 I2CM_slStatus &= (uint8) ~I2CM_I2C_SSTAT_RD_BUSY;
 502:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 I2CM_slStatus |= (uint8)  I2CM_I2C_SSTAT_RD_CMPLT;
 503:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 I2CM_state     =  I2CM_I2C_FSM_IDLE;
 504:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****             }
 505:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** 
 506:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** 
 507:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****             /* INTR_SLAVE_I2C_WRITE_STOP:
ARM GAS  C:\Users\SNFU\AppData\Local\Temp\ccgMdgju.s 			page 20


 508:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****             * The master completes writing to the slave: the appropriate flags have to be set.
 509:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****             * The RX FIFO contains 1-8 bytes from the previous transaction which needs to be read.
 510:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****             * There is a possibility that the RX FIFO contains an address, it needs to leave it the
 511:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****             */
 512:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****             if(I2CM_CHECK_INTR_SLAVE_MASKED(I2CM_INTR_SLAVE_I2C_WRITE_STOP))
 513:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****             {
 514:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 I2CM_ClearSlaveInterruptSource(I2CM_INTR_SLAVE_I2C_WRITE_STOP);
 515:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** 
 516:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 /* Read bytes from the RX FIFO when auto data ACK receive logic is enabled. Otherwi
 517:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 * were already read from the RX FIFO accept address byte which has to stay here to 
 518:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 * I2C_ADDR_MATCH.
 519:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 */
 520:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 if (0u != (I2CM_I2C_CTRL_REG & I2CM_I2C_CTRL_S_READY_DATA_ACK))
 521:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 {
 522:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     while(0u != I2CM_GET_RX_FIFO_ENTRIES)
 523:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     {
 524:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         #if(I2CM_CHECK_I2C_ACCEPT_ADDRESS)
 525:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         {
 526:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                             if((1u == I2CM_GET_RX_FIFO_ENTRIES) &&
 527:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                                (I2CM_CHECK_INTR_SLAVE_MASKED(I2CM_INTR_SLAVE_I2C_ADDR_MATCH)))
 528:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                             {
 529:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                                 break; /* Leave address in RX FIFO */
 530:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                             }
 531:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         }
 532:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         #endif
 533:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** 
 534:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         /* Put data in component buffer */
 535:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         I2CM_slWrBufPtr[I2CM_slWrBufIndex] = (uint8) I2CM_RX_FIFO_RD_REG;
 536:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         I2CM_slWrBufIndex++;
 537:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     }
 538:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     
 539:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     I2CM_DISABLE_SLAVE_AUTO_DATA;
 540:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 }
 541:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** 
 542:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 if(I2CM_CHECK_INTR_RX(I2CM_INTR_RX_OVERFLOW))
 543:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 {
 544:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     I2CM_slStatus |= (uint8) I2CM_I2C_SSTAT_WR_OVFL;
 545:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 }
 546:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** 
 547:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 /* Clears RX interrupt sources triggered on data receiving */
 548:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 I2CM_SetRxInterruptMode(I2CM_NO_INTR_SOURCES);
 549:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 I2CM_ClearRxInterruptSource(I2CM_INTR_RX_ALL);
 550:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** 
 551:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 /* Complete master writing */
 552:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 I2CM_slStatus &= (uint8) ~I2CM_I2C_SSTAT_WR_BUSY;
 553:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 I2CM_slStatus |= (uint8)  I2CM_I2C_SSTAT_WR_CMPLT;
 554:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 I2CM_state     =  I2CM_I2C_FSM_IDLE;
 555:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****             }
 556:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** 
 557:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** 
 558:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****             /* INTR_SLAVE_I2C_ADDR_MATCH:
 559:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****             * The address match event starts the slave operation: after leaving the TX or RX
 560:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****             * direction has to be chosen.
 561:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****             * The wakeup interrupt must be cleared only after an address match is set.
 562:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****             */
 563:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****             if(I2CM_CHECK_INTR_SLAVE_MASKED(I2CM_INTR_SLAVE_I2C_ADDR_MATCH))
 564:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****             {
ARM GAS  C:\Users\SNFU\AppData\Local\Temp\ccgMdgju.s 			page 21


 565:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 #if(I2CM_CHECK_I2C_ACCEPT_ADDRESS)
 566:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 {
 567:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     address = I2CM_RX_FIFO_RD_REG; /* Address in the RX FIFO */
 568:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** 
 569:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     /* Clears RX sources if address was received in RX FIFO */
 570:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     I2CM_ClearRxInterruptSource(I2CM_INTR_RX_ALL);
 571:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** 
 572:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     if(0u != address)
 573:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     {
 574:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         /* Suppress compiler warning */
 575:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     }
 576:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 }
 577:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 #endif
 578:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** 
 579:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 if(I2CM_CHECK_I2C_STATUS(I2CM_I2C_STATUS_S_READ))
 580:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 /* TX direction: master reads from slave */
 581:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 {
 582:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     I2CM_SetTxInterruptMode(I2CM_INTR_TX_EMPTY);
 583:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** 
 584:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     /* Set temporary index to address buffer clear from API */
 585:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     I2CM_slRdBufIndexTmp = I2CM_slRdBufIndex;
 586:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** 
 587:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     /* Start master reading */
 588:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     I2CM_slStatus |= (uint8) I2CM_I2C_SSTAT_RD_BUSY;
 589:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     I2CM_state     = I2CM_I2C_FSM_SL_RD;
 590:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 }
 591:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 else
 592:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 /* RX direction: master writes into slave */
 593:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 {
 594:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     /* Calculate available buffer size */
 595:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     diffCount = (I2CM_slWrBufSize - I2CM_slWrBufIndex);
 596:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** 
 597:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 #if (I2CM_CY_SCBIP_V0)
 598:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     
 599:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     if(diffCount < I2CM_FIFO_SIZE)
 600:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     /* Receive data: byte-by-byte */
 601:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     {
 602:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         I2CM_SetRxInterruptMode(I2CM_INTR_RX_NOT_EMPTY);
 603:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     }
 604:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     else
 605:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     /* Receive data: into RX FIFO */
 606:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     {
 607:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         if(diffCount == I2CM_FIFO_SIZE)
 608:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         {
 609:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                             /* NACK when RX FIFO become FULL */
 610:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                             I2CM_ENABLE_SLAVE_AUTO_DATA;
 611:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         }
 612:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         else
 613:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         {
 614:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                             /* Stretch clock when RX FIFO becomes FULL */
 615:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                             I2CM_ENABLE_SLAVE_AUTO_DATA_ACK;
 616:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                             I2CM_SetRxInterruptMode(I2CM_INTR_RX_FULL);
 617:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         }
 618:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     }
 619:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     
 620:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 #else
 621:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     
ARM GAS  C:\Users\SNFU\AppData\Local\Temp\ccgMdgju.s 			page 22


 622:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     #if(I2CM_CHECK_I2C_ACCEPT_ADDRESS)
 623:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     {
 624:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         /* Enable RX.NOT_EMPTY interrupt source to receive byte by byte.
 625:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         * The byte by byte receive is always chosen for when address is accpected i
 626:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         * Ticket ID#175559.
 627:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         */
 628:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         I2CM_SetRxInterruptMode(I2CM_INTR_RX_NOT_EMPTY);
 629:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     }
 630:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     #else
 631:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     {
 632:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         if(diffCount < I2CM_FIFO_SIZE)
 633:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         /* Receive data: byte-by-byte */
 634:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         {
 635:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                             I2CM_SetRxInterruptMode(I2CM_INTR_RX_NOT_EMPTY);
 636:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         }
 637:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         else
 638:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         /* Receive data: into RX FIFO */
 639:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         {
 640:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                             if(diffCount == I2CM_FIFO_SIZE)
 641:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                             {
 642:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                                 /* NACK when RX FIFO become FULL */
 643:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                                 I2CM_ENABLE_SLAVE_AUTO_DATA;
 644:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                             }
 645:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                             else
 646:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                             {
 647:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                                 /* Stretch clock when RX FIFO becomes FULL */
 648:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                                 I2CM_ENABLE_SLAVE_AUTO_DATA_ACK;
 649:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                                 I2CM_SetRxInterruptMode(I2CM_INTR_RX_FULL);
 650:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                             }
 651:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         }
 652:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     }
 653:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     #endif
 654:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     
 655:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 #endif /* (I2CM_CY_SCBIP_V0) */
 656:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** 
 657:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     /* Start master reading */
 658:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     I2CM_slStatus |= (uint8) I2CM_I2C_SSTAT_WR_BUSY;
 659:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     I2CM_state     = I2CM_I2C_FSM_SL_WR;
 660:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 }
 661:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** 
 662:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 /* Clear interrupts before ACK address */
 663:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 I2CM_ClearI2CExtClkInterruptSource(I2CM_INTR_I2C_EC_WAKE_UP);
 664:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 I2CM_ClearSlaveInterruptSource(I2CM_INTR_SLAVE_ALL);
 665:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** 
 666:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 /* The preparation complete: ACK the address */
 667:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 I2CM_I2C_SLAVE_GENERATE_ACK;
 668:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****             }
 669:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** 
 670:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****             /* I2CM_INTR_RX_FULL":
 671:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****             * Get data from the RX FIFO and decide whether to ACK or NACK the following bytes
 672:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****             */
 673:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****             if(I2CM_CHECK_INTR_RX_MASKED(I2CM_INTR_RX_FULL))
 674:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****             {
 675:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 /* Calculate available buffer size to take into account that RX FIFO is FULL */
 676:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 diffCount =  I2CM_slWrBufSize -
 677:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                             (I2CM_slWrBufIndex + I2CM_FIFO_SIZE);
 678:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** 
ARM GAS  C:\Users\SNFU\AppData\Local\Temp\ccgMdgju.s 			page 23


 679:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 if(diffCount > I2CM_FIFO_SIZE) /* Proceed transaction */
 680:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 {
 681:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     diffCount   = I2CM_FIFO_SIZE;
 682:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     endTransfer = 0u;  /* Continue active transfer */
 683:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 }
 684:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 else /* End when FIFO becomes FULL again */
 685:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 {
 686:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     endTransfer = I2CM_I2C_CMPLT_ANY_TRANSFER;
 687:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 }
 688:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** 
 689:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 for(; (0u != diffCount); diffCount--)
 690:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 {
 691:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     /* Put data in component buffer */
 692:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     I2CM_slWrBufPtr[I2CM_slWrBufIndex] = (uint8) I2CM_RX_FIFO_RD_REG;
 693:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     I2CM_slWrBufIndex++;
 694:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 }
 695:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** 
 696:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 if(0u != endTransfer) /* End transfer sending NACK */
 697:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 {
 698:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     I2CM_ENABLE_SLAVE_AUTO_DATA_NACK;
 699:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** 
 700:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     /* The INTR_RX_FULL triggers earlier than INTR_SLAVE_I2C_STOP:
 701:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     * disable all the RX interrupt sources.
 702:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     */
 703:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     I2CM_SetRxInterruptMode(I2CM_NO_INTR_SOURCES);
 704:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 }
 705:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** 
 706:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 I2CM_ClearRxInterruptSource(I2CM_INTR_RX_FULL);
 707:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****             }
 708:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****             /* I2CM_INTR_RX_NOT_EMPTY:
 709:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****             * The buffer size is less than 8: it requires processing in byte-by-byte mode.
 710:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****             */
 711:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****             else if(I2CM_CHECK_INTR_RX_MASKED(I2CM_INTR_RX_NOT_EMPTY))
 712:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****             {
 713:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 diffCount = I2CM_RX_FIFO_RD_REG;
 714:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** 
 715:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 if(I2CM_slWrBufIndex < I2CM_slWrBufSize)
 716:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 {
 717:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     I2CM_I2C_SLAVE_GENERATE_ACK;
 718:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** 
 719:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     /* Put data into component buffer */
 720:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     I2CM_slWrBufPtr[I2CM_slWrBufIndex] = (uint8) diffCount;
 721:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     I2CM_slWrBufIndex++;
 722:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 }
 723:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 else /* Overflow: there is no space in write buffer */
 724:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 {
 725:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     I2CM_I2C_SLAVE_GENERATE_NACK;
 726:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** 
 727:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     I2CM_slStatus |= (uint8) I2CM_I2C_SSTAT_WR_OVFL;
 728:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 }
 729:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** 
 730:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 I2CM_ClearRxInterruptSource(I2CM_INTR_RX_NOT_EMPTY);
 731:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****             }
 732:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****             else
 733:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****             {
 734:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 /* Does nothing */
 735:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****             }
ARM GAS  C:\Users\SNFU\AppData\Local\Temp\ccgMdgju.s 			page 24


 736:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** 
 737:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** 
 738:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****             /* I2CM_INTR_TX_EMPTY:
 739:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****             * The master reads the slave: provide data to read or 0xFF in case of the end of the bu
 740:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****             * The overflow condition must be captured, but not set until the end of a transaction.
 741:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****             * There is a possibility of a false overflow due of the TX FIFO utilization.
 742:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****             */
 743:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****             if(I2CM_CHECK_INTR_TX_MASKED(I2CM_INTR_TX_EMPTY))
 744:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****             {
 745:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 while(I2CM_FIFO_SIZE != I2CM_GET_TX_FIFO_ENTRIES)
 746:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 {
 747:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     /* The temporary slRdBufIndexTmp is used because the master could NACK the byte
 748:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     * index roll-back is required in this case. The slRdBufIndex is updated at the 
 749:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     * of the read transfer.
 750:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     */
 751:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     if(I2CM_slRdBufIndexTmp < I2CM_slRdBufSize)
 752:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     /* Data from buffer */
 753:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     {
 754:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         I2CM_TX_FIFO_WR_REG = (uint32) I2CM_slRdBufPtr[I2CM_slRdBufIndexTmp];
 755:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         I2CM_slRdBufIndexTmp++;
 756:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     }
 757:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     else
 758:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     /* Probably Overflow */
 759:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     {
 760:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         I2CM_TX_FIFO_WR_REG = I2CM_I2C_SLAVE_OVFL_RETURN;
 761:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** 
 762:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         if(0u == (I2CM_INTR_TX_OVERFLOW & I2CM_slOverFlowCount))
 763:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         {
 764:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                             /* Get counter in range of the byte: value 10 is overflow */
 765:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                             I2CM_slOverFlowCount++;
 766:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                         }
 767:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                     }
 768:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 }
 769:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** 
 770:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****                 I2CM_ClearTxInterruptSource(I2CM_INTR_TX_EMPTY);
 771:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****             }
 772:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** 
 773:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****         }  /* (I2CM_I2C_SLAVE) */
 774:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****         #endif
 775:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****     }
 776:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** 
 777:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** 
 778:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****     /* FSM EXIT:
 779:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****     * Slave:  INTR_SLAVE_I2C_BUS_ERROR, INTR_SLAVE_I2C_ARB_LOST
 780:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****     * Master: INTR_MASTER_I2C_BUS_ERROR, INTR_MASTER_I2C_ARB_LOST.
 781:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****     */
 782:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****     else
 783:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****     {
 784:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****         I2CM_CTRL_REG &= (uint32) ~I2CM_CTRL_ENABLED; /* Disable SCB block */
 553              		.loc 1 784 0
 554 026c 3349     		ldr	r1, .L75+132
 555              	.LVL65:
 556 026e 0F68     		ldr	r7, [r1]
 557 0270 7800     		lsl	r0, r7, #1
 558 0272 4408     		lsr	r4, r0, #1
 559 0274 0C60     		str	r4, [r1]
 785:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** 
ARM GAS  C:\Users\SNFU\AppData\Local\Temp\ccgMdgju.s 			page 25


 786:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****         I2CM_state = I2CM_I2C_FSM_IDLE;
 560              		.loc 1 786 0
 561 0276 1A70     		strb	r2, [r3]
 787:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** 
 788:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****         I2CM_DISABLE_SLAVE_AUTO_DATA;
 562              		.loc 1 788 0
 563 0278 1C4B     		ldr	r3, .L75+52
 564 027a 314A     		ldr	r2, .L75+136
 565 027c 1D68     		ldr	r5, [r3]
 789:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****         I2CM_DISABLE_MASTER_AUTO_DATA;
 566              		.loc 1 789 0
 567 027e 3148     		ldr	r0, .L75+140
 788:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****         I2CM_DISABLE_SLAVE_AUTO_DATA;
 568              		.loc 1 788 0
 569 0280 2A40     		and	r2, r5
 570 0282 1A60     		str	r2, [r3]
 571              		.loc 1 789 0
 572 0284 1F68     		ldr	r7, [r3]
 790:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** 
 791:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****     #if(I2CM_CY_SCBIP_V0)
 792:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****         I2CM_SetRxInterruptMode(I2CM_NO_INTR_SOURCES);
 573              		.loc 1 792 0
 574 0286 2A4C     		ldr	r4, .L75+120
 789:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****         I2CM_DISABLE_MASTER_AUTO_DATA;
 575              		.loc 1 789 0
 576 0288 3840     		and	r0, r7
 577 028a 1860     		str	r0, [r3]
 793:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****         I2CM_SetTxInterruptMode(I2CM_NO_INTR_SOURCES);
 578              		.loc 1 793 0
 579 028c 124B     		ldr	r3, .L75+32
 792:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****         I2CM_SetRxInterruptMode(I2CM_NO_INTR_SOURCES);
 580              		.loc 1 792 0
 581 028e 2660     		str	r6, [r4]
 794:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** 
 795:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****         /* Clear interrupt sources as they are not automatically cleared after SCB is disabled */
 796:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****         I2CM_ClearTxInterruptSource(I2CM_INTR_RX_ALL);
 582              		.loc 1 796 0
 583 0290 264D     		ldr	r5, .L75+116
 793:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****         I2CM_SetTxInterruptMode(I2CM_NO_INTR_SOURCES);
 584              		.loc 1 793 0
 585 0292 1E60     		str	r6, [r3]
 586              		.loc 1 796 0
 587 0294 1A4E     		ldr	r6, .L75+72
 797:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****         I2CM_ClearRxInterruptSource(I2CM_INTR_TX_ALL);
 588              		.loc 1 797 0
 589 0296 244A     		ldr	r2, .L75+112
 796:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****         I2CM_ClearTxInterruptSource(I2CM_INTR_RX_ALL);
 590              		.loc 1 796 0
 591 0298 2E60     		str	r6, [r5]
 592              		.loc 1 797 0
 593 029a 1A4F     		ldr	r7, .L75+76
 798:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****         I2CM_ClearSlaveInterruptSource(I2CM_INTR_SLAVE_ALL);
 594              		.loc 1 798 0
 595 029c 2A48     		ldr	r0, .L75+144
 596 029e 2B4C     		ldr	r4, .L75+148
 799:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****         I2CM_ClearMasterInterruptSource(I2CM_INTR_MASTER_ALL);
 597              		.loc 1 799 0
ARM GAS  C:\Users\SNFU\AppData\Local\Temp\ccgMdgju.s 			page 26


 598 02a0 2B4E     		ldr	r6, .L75+152
 599 02a2 0B4B     		ldr	r3, .L75+24
 797:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****         I2CM_ClearRxInterruptSource(I2CM_INTR_TX_ALL);
 600              		.loc 1 797 0
 601 02a4 3A60     		str	r2, [r7]
 798:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****         I2CM_ClearSlaveInterruptSource(I2CM_INTR_SLAVE_ALL);
 602              		.loc 1 798 0
 603 02a6 2060     		str	r0, [r4]
 604              		.loc 1 799 0
 605 02a8 1E60     		str	r6, [r3]
 800:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****     #endif /* (I2CM_CY_SCBIP_V0) */
 801:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** 
 802:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****         I2CM_CTRL_REG |= (uint32) I2CM_CTRL_ENABLED;  /* Enable SCB block */
 606              		.loc 1 802 0
 607 02aa 0D68     		ldr	r5, [r1]
 608 02ac 8022     		mov	r2, #128
 609 02ae 1706     		lsl	r7, r2, #24
 610 02b0 2F43     		orr	r7, r5
 611 02b2 0F60     		str	r7, [r1]
 612              	.LVL66:
 613              	.L1:
 803:.\Generated_Source\PSoC4/I2CM_I2C_INT.c ****     }
 804:.\Generated_Source\PSoC4/I2CM_I2C_INT.c **** }
 614              		.loc 1 804 0
 615              		@ sp needed for prologue
 616              	.LVL67:
 617              	.LVL68:
 618 02b4 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 619              	.L76:
 620 02b6 C046     		.align	2
 621              	.L75:
 622 02b8 00000000 		.word	I2CM_customIntrHandler
 623 02bc 8C0E0740 		.word	1074204300
 624 02c0 880E0740 		.word	1074204296
 625 02c4 00000000 		.word	I2CM_state
 626 02c8 0C0F0740 		.word	1074204428
 627 02cc 00000000 		.word	I2CM_mstrStatus
 628 02d0 000F0740 		.word	1074204416
 629 02d4 00000000 		.word	I2CM_mstrWrBufSize
 630 02d8 880F0740 		.word	1074204552
 631 02dc CC0F0740 		.word	1074204620
 632 02e0 00000000 		.word	I2CM_mstrRdBufSize
 633 02e4 08030740 		.word	1074201352
 634 02e8 00000000 		.word	I2CM_mstrRdBufIndex
 635 02ec 60000740 		.word	1074200672
 636 02f0 FFFEFFFF 		.word	-257
 637 02f4 00000000 		.word	I2CM_mstrRdBufPtr
 638 02f8 40030740 		.word	1074201408
 639 02fc 68000740 		.word	1074200680
 640 0300 ED0F0000 		.word	4077
 641 0304 C00F0740 		.word	1074204608
 642 0308 00000000 		.word	I2CM_mstrWrBufIndexTmp
 643 030c 08020740 		.word	1074201096
 644 0310 00000000 		.word	I2CM_mstrWrBufIndex
 645 0314 04020740 		.word	1074201092
 646 0318 FFFFFEFF 		.word	-65537
 647 031c 8C0F0740 		.word	1074204556
ARM GAS  C:\Users\SNFU\AppData\Local\Temp\ccgMdgju.s 			page 27


 648 0320 00000000 		.word	I2CM_mstrWrBufPtr
 649 0324 40020740 		.word	1074201152
 650 0328 F3070000 		.word	2035
 651 032c 800F0740 		.word	1074204544
 652 0330 C80F0740 		.word	1074204616
 653 0334 00000000 		.word	I2CM_mstrControl
 654 0338 64000740 		.word	1074200676
 655 033c 00000740 		.word	1074200576
 656 0340 FF5FFFFF 		.word	-40961
 657 0344 FFFCFFFF 		.word	-769
 658 0348 FF0F0000 		.word	4095
 659 034c 400F0740 		.word	1074204480
 660 0350 17030000 		.word	791
 661              		.cfi_endproc
 662              	.LFE0:
 663              		.size	I2CM_I2C_ISR, .-I2CM_I2C_ISR
 664              		.text
 665              	.Letext0:
 666              		.file 2 "./Generated_Source/PSoC4/cytypes.h"
 667              		.file 3 ".\\Generated_Source\\PSoC4\\I2CM_PVT.h"
 668              		.file 4 ".\\Generated_Source\\PSoC4\\I2CM_I2C_PVT.h"
 669              		.section	.debug_info,"",%progbits
 670              	.Ldebug_info0:
 671 0000 A5010000 		.4byte	0x1a5
 672 0004 0200     		.2byte	0x2
 673 0006 00000000 		.4byte	.Ldebug_abbrev0
 674 000a 04       		.byte	0x4
 675 000b 01       		.uleb128 0x1
 676 000c 03020000 		.4byte	.LASF31
 677 0010 01       		.byte	0x1
 678 0011 BF000000 		.4byte	.LASF32
 679 0015 67000000 		.4byte	.LASF33
 680 0019 00000000 		.4byte	.Ldebug_ranges0+0
 681 001d 00000000 		.4byte	0
 682 0021 00000000 		.4byte	0
 683 0025 00000000 		.4byte	.Ldebug_line0
 684 0029 02       		.uleb128 0x2
 685 002a 01       		.byte	0x1
 686 002b 06       		.byte	0x6
 687 002c 55020000 		.4byte	.LASF0
 688 0030 02       		.uleb128 0x2
 689 0031 01       		.byte	0x1
 690 0032 08       		.byte	0x8
 691 0033 40010000 		.4byte	.LASF1
 692 0037 02       		.uleb128 0x2
 693 0038 02       		.byte	0x2
 694 0039 05       		.byte	0x5
 695 003a F9010000 		.4byte	.LASF2
 696 003e 02       		.uleb128 0x2
 697 003f 02       		.byte	0x2
 698 0040 07       		.byte	0x7
 699 0041 2D000000 		.4byte	.LASF3
 700 0045 02       		.uleb128 0x2
 701 0046 04       		.byte	0x4
 702 0047 05       		.byte	0x5
 703 0048 4C020000 		.4byte	.LASF4
 704 004c 02       		.uleb128 0x2
ARM GAS  C:\Users\SNFU\AppData\Local\Temp\ccgMdgju.s 			page 28


 705 004d 04       		.byte	0x4
 706 004e 07       		.byte	0x7
 707 004f 63010000 		.4byte	.LASF5
 708 0053 02       		.uleb128 0x2
 709 0054 08       		.byte	0x8
 710 0055 05       		.byte	0x5
 711 0056 C3010000 		.4byte	.LASF6
 712 005a 02       		.uleb128 0x2
 713 005b 08       		.byte	0x8
 714 005c 07       		.byte	0x7
 715 005d 96010000 		.4byte	.LASF7
 716 0061 03       		.uleb128 0x3
 717 0062 04       		.byte	0x4
 718 0063 05       		.byte	0x5
 719 0064 696E7400 		.ascii	"int\000"
 720 0068 02       		.uleb128 0x2
 721 0069 04       		.byte	0x4
 722 006a 07       		.byte	0x7
 723 006b 75010000 		.4byte	.LASF8
 724 006f 04       		.uleb128 0x4
 725 0070 11010000 		.4byte	.LASF9
 726 0074 02       		.byte	0x2
 727 0075 5B       		.byte	0x5b
 728 0076 30000000 		.4byte	0x30
 729 007a 04       		.uleb128 0x4
 730 007b 55010000 		.4byte	.LASF10
 731 007f 02       		.byte	0x2
 732 0080 5C       		.byte	0x5c
 733 0081 3E000000 		.4byte	0x3e
 734 0085 04       		.uleb128 0x4
 735 0086 5C010000 		.4byte	.LASF11
 736 008a 02       		.byte	0x2
 737 008b 5D       		.byte	0x5d
 738 008c 4C000000 		.4byte	0x4c
 739 0090 02       		.uleb128 0x2
 740 0091 04       		.byte	0x4
 741 0092 04       		.byte	0x4
 742 0093 B9000000 		.4byte	.LASF12
 743 0097 02       		.uleb128 0x2
 744 0098 08       		.byte	0x8
 745 0099 04       		.byte	0x4
 746 009a 4E010000 		.4byte	.LASF13
 747 009e 02       		.uleb128 0x2
 748 009f 01       		.byte	0x1
 749 00a0 08       		.byte	0x8
 750 00a1 E3010000 		.4byte	.LASF14
 751 00a5 05       		.uleb128 0x5
 752 00a6 6F000000 		.4byte	0x6f
 753 00aa 05       		.uleb128 0x5
 754 00ab 7A000000 		.4byte	0x7a
 755 00af 04       		.uleb128 0x4
 756 00b0 00000000 		.4byte	.LASF15
 757 00b4 02       		.byte	0x2
 758 00b5 F2       		.byte	0xf2
 759 00b6 BA000000 		.4byte	0xba
 760 00ba 05       		.uleb128 0x5
 761 00bb 85000000 		.4byte	0x85
ARM GAS  C:\Users\SNFU\AppData\Local\Temp\ccgMdgju.s 			page 29


 762 00bf 06       		.uleb128 0x6
 763 00c0 AD010000 		.4byte	.LASF16
 764 00c4 02       		.byte	0x2
 765 00c5 0201     		.2byte	0x102
 766 00c7 CB000000 		.4byte	0xcb
 767 00cb 07       		.uleb128 0x7
 768 00cc 04       		.byte	0x4
 769 00cd D1000000 		.4byte	0xd1
 770 00d1 08       		.uleb128 0x8
 771 00d2 01       		.byte	0x1
 772 00d3 02       		.uleb128 0x2
 773 00d4 04       		.byte	0x4
 774 00d5 07       		.byte	0x7
 775 00d6 BA010000 		.4byte	.LASF17
 776 00da 09       		.uleb128 0x9
 777 00db 01       		.byte	0x1
 778 00dc FA000000 		.4byte	.LASF34
 779 00e0 01       		.byte	0x1
 780 00e1 24       		.byte	0x24
 781 00e2 01       		.byte	0x1
 782 00e3 00000000 		.4byte	.LFB0
 783 00e7 54030000 		.4byte	.LFE0
 784 00eb 00000000 		.4byte	.LLST0
 785 00ef 01       		.byte	0x1
 786 00f0 13010000 		.4byte	0x113
 787 00f4 0A       		.uleb128 0xa
 788 00f5 07010000 		.4byte	.LASF18
 789 00f9 01       		.byte	0x1
 790 00fa 26       		.byte	0x26
 791 00fb 85000000 		.4byte	0x85
 792 00ff 20000000 		.4byte	.LLST1
 793 0103 0A       		.uleb128 0xa
 794 0104 40000000 		.4byte	.LASF19
 795 0108 01       		.byte	0x1
 796 0109 27       		.byte	0x27
 797 010a 85000000 		.4byte	0x85
 798 010e 4A000000 		.4byte	.LLST2
 799 0112 00       		.byte	0
 800 0113 0B       		.uleb128 0xb
 801 0114 17010000 		.4byte	.LASF20
 802 0118 03       		.byte	0x3
 803 0119 37       		.byte	0x37
 804 011a BF000000 		.4byte	0xbf
 805 011e 01       		.byte	0x1
 806 011f 01       		.byte	0x1
 807 0120 0B       		.uleb128 0xb
 808 0121 4C000000 		.4byte	.LASF21
 809 0125 04       		.byte	0x4
 810 0126 1D       		.byte	0x1d
 811 0127 A5000000 		.4byte	0xa5
 812 012b 01       		.byte	0x1
 813 012c 01       		.byte	0x1
 814 012d 0B       		.uleb128 0xb
 815 012e 57000000 		.4byte	.LASF22
 816 0132 04       		.byte	0x4
 817 0133 30       		.byte	0x30
 818 0134 AA000000 		.4byte	0xaa
ARM GAS  C:\Users\SNFU\AppData\Local\Temp\ccgMdgju.s 			page 30


 819 0138 01       		.byte	0x1
 820 0139 01       		.byte	0x1
 821 013a 0B       		.uleb128 0xb
 822 013b E8010000 		.4byte	.LASF23
 823 013f 04       		.byte	0x4
 824 0140 31       		.byte	0x31
 825 0141 A5000000 		.4byte	0xa5
 826 0145 01       		.byte	0x1
 827 0146 01       		.byte	0x1
 828 0147 0B       		.uleb128 0xb
 829 0148 2E010000 		.4byte	.LASF24
 830 014c 04       		.byte	0x4
 831 014d 34       		.byte	0x34
 832 014e 54010000 		.4byte	0x154
 833 0152 01       		.byte	0x1
 834 0153 01       		.byte	0x1
 835 0154 07       		.uleb128 0x7
 836 0155 04       		.byte	0x4
 837 0156 A5000000 		.4byte	0xa5
 838 015a 0B       		.uleb128 0xb
 839 015b 06000000 		.4byte	.LASF25
 840 015f 04       		.byte	0x4
 841 0160 35       		.byte	0x35
 842 0161 BA000000 		.4byte	0xba
 843 0165 01       		.byte	0x1
 844 0166 01       		.byte	0x1
 845 0167 0B       		.uleb128 0xb
 846 0168 19000000 		.4byte	.LASF26
 847 016c 04       		.byte	0x4
 848 016d 36       		.byte	0x36
 849 016e BA000000 		.4byte	0xba
 850 0172 01       		.byte	0x1
 851 0173 01       		.byte	0x1
 852 0174 0B       		.uleb128 0xb
 853 0175 D1010000 		.4byte	.LASF27
 854 0179 04       		.byte	0x4
 855 017a 39       		.byte	0x39
 856 017b 54010000 		.4byte	0x154
 857 017f 01       		.byte	0x1
 858 0180 01       		.byte	0x1
 859 0181 0B       		.uleb128 0xb
 860 0182 E7000000 		.4byte	.LASF28
 861 0186 04       		.byte	0x4
 862 0187 3A       		.byte	0x3a
 863 0188 BA000000 		.4byte	0xba
 864 018c 01       		.byte	0x1
 865 018d 01       		.byte	0x1
 866 018e 0B       		.uleb128 0xb
 867 018f 82010000 		.4byte	.LASF29
 868 0193 04       		.byte	0x4
 869 0194 3B       		.byte	0x3b
 870 0195 BA000000 		.4byte	0xba
 871 0199 01       		.byte	0x1
 872 019a 01       		.byte	0x1
 873 019b 0B       		.uleb128 0xb
 874 019c 61020000 		.4byte	.LASF30
 875 01a0 04       		.byte	0x4
ARM GAS  C:\Users\SNFU\AppData\Local\Temp\ccgMdgju.s 			page 31


 876 01a1 3C       		.byte	0x3c
 877 01a2 BA000000 		.4byte	0xba
 878 01a6 01       		.byte	0x1
 879 01a7 01       		.byte	0x1
 880 01a8 00       		.byte	0
 881              		.section	.debug_abbrev,"",%progbits
 882              	.Ldebug_abbrev0:
 883 0000 01       		.uleb128 0x1
 884 0001 11       		.uleb128 0x11
 885 0002 01       		.byte	0x1
 886 0003 25       		.uleb128 0x25
 887 0004 0E       		.uleb128 0xe
 888 0005 13       		.uleb128 0x13
 889 0006 0B       		.uleb128 0xb
 890 0007 03       		.uleb128 0x3
 891 0008 0E       		.uleb128 0xe
 892 0009 1B       		.uleb128 0x1b
 893 000a 0E       		.uleb128 0xe
 894 000b 55       		.uleb128 0x55
 895 000c 06       		.uleb128 0x6
 896 000d 11       		.uleb128 0x11
 897 000e 01       		.uleb128 0x1
 898 000f 52       		.uleb128 0x52
 899 0010 01       		.uleb128 0x1
 900 0011 10       		.uleb128 0x10
 901 0012 06       		.uleb128 0x6
 902 0013 00       		.byte	0
 903 0014 00       		.byte	0
 904 0015 02       		.uleb128 0x2
 905 0016 24       		.uleb128 0x24
 906 0017 00       		.byte	0
 907 0018 0B       		.uleb128 0xb
 908 0019 0B       		.uleb128 0xb
 909 001a 3E       		.uleb128 0x3e
 910 001b 0B       		.uleb128 0xb
 911 001c 03       		.uleb128 0x3
 912 001d 0E       		.uleb128 0xe
 913 001e 00       		.byte	0
 914 001f 00       		.byte	0
 915 0020 03       		.uleb128 0x3
 916 0021 24       		.uleb128 0x24
 917 0022 00       		.byte	0
 918 0023 0B       		.uleb128 0xb
 919 0024 0B       		.uleb128 0xb
 920 0025 3E       		.uleb128 0x3e
 921 0026 0B       		.uleb128 0xb
 922 0027 03       		.uleb128 0x3
 923 0028 08       		.uleb128 0x8
 924 0029 00       		.byte	0
 925 002a 00       		.byte	0
 926 002b 04       		.uleb128 0x4
 927 002c 16       		.uleb128 0x16
 928 002d 00       		.byte	0
 929 002e 03       		.uleb128 0x3
 930 002f 0E       		.uleb128 0xe
 931 0030 3A       		.uleb128 0x3a
 932 0031 0B       		.uleb128 0xb
ARM GAS  C:\Users\SNFU\AppData\Local\Temp\ccgMdgju.s 			page 32


 933 0032 3B       		.uleb128 0x3b
 934 0033 0B       		.uleb128 0xb
 935 0034 49       		.uleb128 0x49
 936 0035 13       		.uleb128 0x13
 937 0036 00       		.byte	0
 938 0037 00       		.byte	0
 939 0038 05       		.uleb128 0x5
 940 0039 35       		.uleb128 0x35
 941 003a 00       		.byte	0
 942 003b 49       		.uleb128 0x49
 943 003c 13       		.uleb128 0x13
 944 003d 00       		.byte	0
 945 003e 00       		.byte	0
 946 003f 06       		.uleb128 0x6
 947 0040 16       		.uleb128 0x16
 948 0041 00       		.byte	0
 949 0042 03       		.uleb128 0x3
 950 0043 0E       		.uleb128 0xe
 951 0044 3A       		.uleb128 0x3a
 952 0045 0B       		.uleb128 0xb
 953 0046 3B       		.uleb128 0x3b
 954 0047 05       		.uleb128 0x5
 955 0048 49       		.uleb128 0x49
 956 0049 13       		.uleb128 0x13
 957 004a 00       		.byte	0
 958 004b 00       		.byte	0
 959 004c 07       		.uleb128 0x7
 960 004d 0F       		.uleb128 0xf
 961 004e 00       		.byte	0
 962 004f 0B       		.uleb128 0xb
 963 0050 0B       		.uleb128 0xb
 964 0051 49       		.uleb128 0x49
 965 0052 13       		.uleb128 0x13
 966 0053 00       		.byte	0
 967 0054 00       		.byte	0
 968 0055 08       		.uleb128 0x8
 969 0056 15       		.uleb128 0x15
 970 0057 00       		.byte	0
 971 0058 27       		.uleb128 0x27
 972 0059 0C       		.uleb128 0xc
 973 005a 00       		.byte	0
 974 005b 00       		.byte	0
 975 005c 09       		.uleb128 0x9
 976 005d 2E       		.uleb128 0x2e
 977 005e 01       		.byte	0x1
 978 005f 3F       		.uleb128 0x3f
 979 0060 0C       		.uleb128 0xc
 980 0061 03       		.uleb128 0x3
 981 0062 0E       		.uleb128 0xe
 982 0063 3A       		.uleb128 0x3a
 983 0064 0B       		.uleb128 0xb
 984 0065 3B       		.uleb128 0x3b
 985 0066 0B       		.uleb128 0xb
 986 0067 27       		.uleb128 0x27
 987 0068 0C       		.uleb128 0xc
 988 0069 11       		.uleb128 0x11
 989 006a 01       		.uleb128 0x1
ARM GAS  C:\Users\SNFU\AppData\Local\Temp\ccgMdgju.s 			page 33


 990 006b 12       		.uleb128 0x12
 991 006c 01       		.uleb128 0x1
 992 006d 40       		.uleb128 0x40
 993 006e 06       		.uleb128 0x6
 994 006f 9642     		.uleb128 0x2116
 995 0071 0C       		.uleb128 0xc
 996 0072 01       		.uleb128 0x1
 997 0073 13       		.uleb128 0x13
 998 0074 00       		.byte	0
 999 0075 00       		.byte	0
 1000 0076 0A       		.uleb128 0xa
 1001 0077 34       		.uleb128 0x34
 1002 0078 00       		.byte	0
 1003 0079 03       		.uleb128 0x3
 1004 007a 0E       		.uleb128 0xe
 1005 007b 3A       		.uleb128 0x3a
 1006 007c 0B       		.uleb128 0xb
 1007 007d 3B       		.uleb128 0x3b
 1008 007e 0B       		.uleb128 0xb
 1009 007f 49       		.uleb128 0x49
 1010 0080 13       		.uleb128 0x13
 1011 0081 02       		.uleb128 0x2
 1012 0082 06       		.uleb128 0x6
 1013 0083 00       		.byte	0
 1014 0084 00       		.byte	0
 1015 0085 0B       		.uleb128 0xb
 1016 0086 34       		.uleb128 0x34
 1017 0087 00       		.byte	0
 1018 0088 03       		.uleb128 0x3
 1019 0089 0E       		.uleb128 0xe
 1020 008a 3A       		.uleb128 0x3a
 1021 008b 0B       		.uleb128 0xb
 1022 008c 3B       		.uleb128 0x3b
 1023 008d 0B       		.uleb128 0xb
 1024 008e 49       		.uleb128 0x49
 1025 008f 13       		.uleb128 0x13
 1026 0090 3F       		.uleb128 0x3f
 1027 0091 0C       		.uleb128 0xc
 1028 0092 3C       		.uleb128 0x3c
 1029 0093 0C       		.uleb128 0xc
 1030 0094 00       		.byte	0
 1031 0095 00       		.byte	0
 1032 0096 00       		.byte	0
 1033              		.section	.debug_loc,"",%progbits
 1034              	.Ldebug_loc0:
 1035              	.LLST0:
 1036 0000 00000000 		.4byte	.LFB0
 1037 0004 02000000 		.4byte	.LCFI0
 1038 0008 0200     		.2byte	0x2
 1039 000a 7D       		.byte	0x7d
 1040 000b 00       		.sleb128 0
 1041 000c 02000000 		.4byte	.LCFI0
 1042 0010 54030000 		.4byte	.LFE0
 1043 0014 0200     		.2byte	0x2
 1044 0016 7D       		.byte	0x7d
 1045 0017 18       		.sleb128 24
 1046 0018 00000000 		.4byte	0
ARM GAS  C:\Users\SNFU\AppData\Local\Temp\ccgMdgju.s 			page 34


 1047 001c 00000000 		.4byte	0
 1048              	.LLST1:
 1049 0020 0A010000 		.4byte	.LVL25
 1050 0024 1C010000 		.4byte	.LVL27
 1051 0028 0100     		.2byte	0x1
 1052 002a 52       		.byte	0x52
 1053 002b 1C010000 		.4byte	.LVL27
 1054 002f 1E010000 		.4byte	.LVL28
 1055 0033 0200     		.2byte	0x2
 1056 0035 38       		.byte	0x38
 1057 0036 9F       		.byte	0x9f
 1058 0037 28010000 		.4byte	.LVL30
 1059 003b 3E010000 		.4byte	.LVL33
 1060 003f 0100     		.2byte	0x1
 1061 0041 52       		.byte	0x52
 1062 0042 00000000 		.4byte	0
 1063 0046 00000000 		.4byte	0
 1064              	.LLST2:
 1065 004a 00000000 		.4byte	.LVL0
 1066 004e 22000000 		.4byte	.LVL2
 1067 0052 0200     		.2byte	0x2
 1068 0054 30       		.byte	0x30
 1069 0055 9F       		.byte	0x9f
 1070 0056 26000000 		.4byte	.LVL3
 1071 005a 3E000000 		.4byte	.LVL5
 1072 005e 0200     		.2byte	0x2
 1073 0060 30       		.byte	0x30
 1074 0061 9F       		.byte	0x9f
 1075 0062 3E000000 		.4byte	.LVL5
 1076 0066 40000000 		.4byte	.LVL6
 1077 006a 0200     		.2byte	0x2
 1078 006c 31       		.byte	0x31
 1079 006d 9F       		.byte	0x9f
 1080 006e 40000000 		.4byte	.LVL6
 1081 0072 52000000 		.4byte	.LVL9
 1082 0076 0100     		.2byte	0x1
 1083 0078 57       		.byte	0x57
 1084 0079 52000000 		.4byte	.LVL9
 1085 007d 54000000 		.4byte	.LVL10
 1086 0081 0200     		.2byte	0x2
 1087 0083 31       		.byte	0x31
 1088 0084 9F       		.byte	0x9f
 1089 0085 54000000 		.4byte	.LVL10
 1090 0089 58000000 		.4byte	.LVL11
 1091 008d 0100     		.2byte	0x1
 1092 008f 57       		.byte	0x57
 1093 0090 70000000 		.4byte	.LVL14
 1094 0094 86000000 		.4byte	.LVL16
 1095 0098 0100     		.2byte	0x1
 1096 009a 51       		.byte	0x51
 1097 009b 9C000000 		.4byte	.LVL18
 1098 009f AC000000 		.4byte	.LVL19
 1099 00a3 0100     		.2byte	0x1
 1100 00a5 51       		.byte	0x51
 1101 00a6 BA000000 		.4byte	.LVL21
 1102 00aa BE000000 		.4byte	.LVL22
 1103 00ae 0200     		.2byte	0x2
ARM GAS  C:\Users\SNFU\AppData\Local\Temp\ccgMdgju.s 			page 35


 1104 00b0 31       		.byte	0x31
 1105 00b1 9F       		.byte	0x9f
 1106 00b2 BE000000 		.4byte	.LVL22
 1107 00b6 16010000 		.4byte	.LVL26
 1108 00ba 0100     		.2byte	0x1
 1109 00bc 51       		.byte	0x51
 1110 00bd 1C010000 		.4byte	.LVL27
 1111 00c1 1E010000 		.4byte	.LVL28
 1112 00c5 0200     		.2byte	0x2
 1113 00c7 31       		.byte	0x31
 1114 00c8 9F       		.byte	0x9f
 1115 00c9 3E010000 		.4byte	.LVL33
 1116 00cd 7E010000 		.4byte	.LVL37
 1117 00d1 0100     		.2byte	0x1
 1118 00d3 51       		.byte	0x51
 1119 00d4 BE010000 		.4byte	.LVL45
 1120 00d8 12020000 		.4byte	.LVL52
 1121 00dc 0100     		.2byte	0x1
 1122 00de 51       		.byte	0x51
 1123 00df 18020000 		.4byte	.LVL54
 1124 00e3 1A020000 		.4byte	.LVL55
 1125 00e7 0200     		.2byte	0x2
 1126 00e9 31       		.byte	0x31
 1127 00ea 9F       		.byte	0x9f
 1128 00eb 1A020000 		.4byte	.LVL55
 1129 00ef 1E020000 		.4byte	.LVL56
 1130 00f3 0100     		.2byte	0x1
 1131 00f5 51       		.byte	0x51
 1132 00f6 66020000 		.4byte	.LVL63
 1133 00fa 6E020000 		.4byte	.LVL65
 1134 00fe 0100     		.2byte	0x1
 1135 0100 51       		.byte	0x51
 1136 0101 00000000 		.4byte	0
 1137 0105 00000000 		.4byte	0
 1138              		.section	.debug_aranges,"",%progbits
 1139 0000 1C000000 		.4byte	0x1c
 1140 0004 0200     		.2byte	0x2
 1141 0006 00000000 		.4byte	.Ldebug_info0
 1142 000a 04       		.byte	0x4
 1143 000b 00       		.byte	0
 1144 000c 0000     		.2byte	0
 1145 000e 0000     		.2byte	0
 1146 0010 00000000 		.4byte	.LFB0
 1147 0014 54030000 		.4byte	.LFE0-.LFB0
 1148 0018 00000000 		.4byte	0
 1149 001c 00000000 		.4byte	0
 1150              		.section	.debug_ranges,"",%progbits
 1151              	.Ldebug_ranges0:
 1152 0000 00000000 		.4byte	.LFB0
 1153 0004 54030000 		.4byte	.LFE0
 1154 0008 00000000 		.4byte	0
 1155 000c 00000000 		.4byte	0
 1156              		.section	.debug_line,"",%progbits
 1157              	.Ldebug_line0:
 1158 0000 60010000 		.section	.debug_str,"MS",%progbits,1
 1158      02006B00 
 1158      00000201 
ARM GAS  C:\Users\SNFU\AppData\Local\Temp\ccgMdgju.s 			page 36


 1158      FB0E0D00 
 1158      01010101 
 1159              	.LASF15:
 1160 0000 72656733 		.ascii	"reg32\000"
 1160      3200
 1161              	.LASF25:
 1162 0006 4932434D 		.ascii	"I2CM_mstrRdBufSize\000"
 1162      5F6D7374 
 1162      72526442 
 1162      75665369 
 1162      7A6500
 1163              	.LASF26:
 1164 0019 4932434D 		.ascii	"I2CM_mstrRdBufIndex\000"
 1164      5F6D7374 
 1164      72526442 
 1164      7566496E 
 1164      64657800 
 1165              	.LASF3:
 1166 002d 73686F72 		.ascii	"short unsigned int\000"
 1166      7420756E 
 1166      7369676E 
 1166      65642069 
 1166      6E7400
 1167              	.LASF19:
 1168 0040 656E6454 		.ascii	"endTransfer\000"
 1168      72616E73 
 1168      66657200 
 1169              	.LASF21:
 1170 004c 4932434D 		.ascii	"I2CM_state\000"
 1170      5F737461 
 1170      746500
 1171              	.LASF22:
 1172 0057 4932434D 		.ascii	"I2CM_mstrStatus\000"
 1172      5F6D7374 
 1172      72537461 
 1172      74757300 
 1173              	.LASF33:
 1174 0067 433A5C55 		.ascii	"C:\\Users\\SNFU\\Documents\\T-50_UAV_Project\\Softw"
 1174      73657273 
 1174      5C534E46 
 1174      555C446F 
 1174      63756D65 
 1175 0095 6172655C 		.ascii	"are\\T-50_Project\\T-50_Project.cydsn\000"
 1175      542D3530 
 1175      5F50726F 
 1175      6A656374 
 1175      5C542D35 
 1176              	.LASF12:
 1177 00b9 666C6F61 		.ascii	"float\000"
 1177      7400
 1178              	.LASF32:
 1179 00bf 2E5C4765 		.ascii	".\\Generated_Source\\PSoC4\\I2CM_I2C_INT.c\000"
 1179      6E657261 
 1179      7465645F 
 1179      536F7572 
 1179      63655C50 
 1180              	.LASF28:
ARM GAS  C:\Users\SNFU\AppData\Local\Temp\ccgMdgju.s 			page 37


 1181 00e7 4932434D 		.ascii	"I2CM_mstrWrBufSize\000"
 1181      5F6D7374 
 1181      72577242 
 1181      75665369 
 1181      7A6500
 1182              	.LASF34:
 1183 00fa 4932434D 		.ascii	"I2CM_I2C_ISR\000"
 1183      5F493243 
 1183      5F495352 
 1183      00
 1184              	.LASF18:
 1185 0107 64696666 		.ascii	"diffCount\000"
 1185      436F756E 
 1185      7400
 1186              	.LASF9:
 1187 0111 75696E74 		.ascii	"uint8\000"
 1187      3800
 1188              	.LASF20:
 1189 0117 4932434D 		.ascii	"I2CM_customIntrHandler\000"
 1189      5F637573 
 1189      746F6D49 
 1189      6E747248 
 1189      616E646C 
 1190              	.LASF24:
 1191 012e 4932434D 		.ascii	"I2CM_mstrRdBufPtr\000"
 1191      5F6D7374 
 1191      72526442 
 1191      75665074 
 1191      7200
 1192              	.LASF1:
 1193 0140 756E7369 		.ascii	"unsigned char\000"
 1193      676E6564 
 1193      20636861 
 1193      7200
 1194              	.LASF13:
 1195 014e 646F7562 		.ascii	"double\000"
 1195      6C6500
 1196              	.LASF10:
 1197 0155 75696E74 		.ascii	"uint16\000"
 1197      313600
 1198              	.LASF11:
 1199 015c 75696E74 		.ascii	"uint32\000"
 1199      333200
 1200              	.LASF5:
 1201 0163 6C6F6E67 		.ascii	"long unsigned int\000"
 1201      20756E73 
 1201      69676E65 
 1201      6420696E 
 1201      7400
 1202              	.LASF8:
 1203 0175 756E7369 		.ascii	"unsigned int\000"
 1203      676E6564 
 1203      20696E74 
 1203      00
 1204              	.LASF29:
 1205 0182 4932434D 		.ascii	"I2CM_mstrWrBufIndex\000"
 1205      5F6D7374 
ARM GAS  C:\Users\SNFU\AppData\Local\Temp\ccgMdgju.s 			page 38


 1205      72577242 
 1205      7566496E 
 1205      64657800 
 1206              	.LASF7:
 1207 0196 6C6F6E67 		.ascii	"long long unsigned int\000"
 1207      206C6F6E 
 1207      6720756E 
 1207      7369676E 
 1207      65642069 
 1208              	.LASF16:
 1209 01ad 63796973 		.ascii	"cyisraddress\000"
 1209      72616464 
 1209      72657373 
 1209      00
 1210              	.LASF17:
 1211 01ba 73697A65 		.ascii	"sizetype\000"
 1211      74797065 
 1211      00
 1212              	.LASF6:
 1213 01c3 6C6F6E67 		.ascii	"long long int\000"
 1213      206C6F6E 
 1213      6720696E 
 1213      7400
 1214              	.LASF27:
 1215 01d1 4932434D 		.ascii	"I2CM_mstrWrBufPtr\000"
 1215      5F6D7374 
 1215      72577242 
 1215      75665074 
 1215      7200
 1216              	.LASF14:
 1217 01e3 63686172 		.ascii	"char\000"
 1217      00
 1218              	.LASF23:
 1219 01e8 4932434D 		.ascii	"I2CM_mstrControl\000"
 1219      5F6D7374 
 1219      72436F6E 
 1219      74726F6C 
 1219      00
 1220              	.LASF2:
 1221 01f9 73686F72 		.ascii	"short int\000"
 1221      7420696E 
 1221      7400
 1222              	.LASF31:
 1223 0203 474E5520 		.ascii	"GNU C 4.7.3 20130312 (release) [ARM/embedded-4_7-br"
 1223      4320342E 
 1223      372E3320 
 1223      32303133 
 1223      30333132 
 1224 0236 616E6368 		.ascii	"anch revision 196615]\000"
 1224      20726576 
 1224      6973696F 
 1224      6E203139 
 1224      36363135 
 1225              	.LASF4:
 1226 024c 6C6F6E67 		.ascii	"long int\000"
 1226      20696E74 
 1226      00
ARM GAS  C:\Users\SNFU\AppData\Local\Temp\ccgMdgju.s 			page 39


 1227              	.LASF0:
 1228 0255 7369676E 		.ascii	"signed char\000"
 1228      65642063 
 1228      68617200 
 1229              	.LASF30:
 1230 0261 4932434D 		.ascii	"I2CM_mstrWrBufIndexTmp\000"
 1230      5F6D7374 
 1230      72577242 
 1230      7566496E 
 1230      64657854 
 1231              		.ident	"GCC: (GNU Tools for ARM Embedded Processors) 4.7.3 20130312 (release) [ARM/embedded-4_7-br
